<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="Peng Sifan&#39;s self blog!">
  <meta name="author" content="sifan.peng">
  <meta name="keywords" content="">
  <title>Loading chunk {n} failed 的解决方法 ~ 彭思凡的个人网站</title>
  
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

  
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">

  
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css">

  
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">

  
<link rel="stylesheet" href="https://at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">

  
    
<link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

  
  
<link rel="stylesheet" href="/css/main.css">


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>彭思凡的个人网站</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2"
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              <p>星期二, 十二月 1日 2020, 8:47 早上</p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto">
          <div class="markdown-body">
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h1><ul>
<li>前端代码更改后,每次发布到测试环境,用户的页面如果不刷新,会读取缓存,导致页面白掉!</li>
<li>本地没有过，都是打包到服务器上才有</li>
</ul>
<p><strong>error info</strong></p>
<pre><code class="js">Uncaught SyntaxError: Unexpected token &#39;&lt;&#39;
Uncaught ChunkLoadError: Loading chunk 8 failed.
(missing: https://mispaceuat.mihoyo.com/static/js/8.98f2a71fc60af3a81dd1.js)
    at Function.i.e (https://mispaceuat.mihoyo.com/static/js/app.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:1:934)
    at https://mispaceuat.mihoyo.com/static/js/app.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:1:3105
    at https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1229684
    at gl (https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1229833)
    at sc (https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1221601)
    at lc (https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1221526)
    at $l (https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1218556)
    at https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1170263
    at e.unstable_runWithPriority (https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1244959)
    at Ia (https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1169972)
</code></pre>
<h1 id="报错原因分析"><a href="#报错原因分析" class="headerlink" title="报错原因分析:"></a>报错原因分析:</h1><ul>
<li>webpack 打包重命名了改动过的 css 和 js 文件，并删除了原有的文件<ul>
<li>场景 1.用户正在浏览页面时你发包了，并且你启用了懒加载，用户的 html 文件中的 js 和 css 名称就和服务器上的不一致导致</li>
<li>场景 2.用户浏览器有 html 的缓存，访问了上一个版本发布的资源导致</li>
</ul>
</li>
<li>webpack 进行 code spilt 之后某些 bundle 文件 lazy loading 失败</li>
<li>其他原因：<ul>
<li>服务器打包时没有进行<code>rm -f public/dist/*</code>操作</li>
<li>chunk 文件内容是不是被篡改(通过抓包排查)</li>
<li>没有升级版本号导致的问题</li>
</ul>
</li>
</ul>
<h1 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h1><ul>
<li>刷新：会重新获取一遍 html 文档，chunk 对应信息也就刷新<ul>
<li>仅捕获到错误就刷新，很可能出现死循环，因为浏览器或类似于 Nginx 缓存设置的原因，浏览器不一定每次刷新去获取新的 index.html</li>
</ul>
</li>
</ul>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul>
<li><strong>方案 1</strong>：结合重试次数和重试间隔来重试，用 location.reload 方法，相当于触发 F5 刷新页面<ul>
<li>缺点:reload 方法，相当于触发 F5 刷新页面，用户会察觉加载刷新</li>
<li>捕获到了 Loading chunk {n} failed 的错误时，重新渲染目标页面，通过正则检测页面出错：用 window.location.reload(true)刷新页面</li>
</ul>
</li>
</ul>
<pre><code class="js">// prompt user to confirm refresh
function forceRefresh() &#123;
  // 设置只强制刷行一次页面
  if (location.href.indexOf(&#39;#reloaded&#39;) === -1) &#123;
    location.href = location.href + &#39;#reloaded&#39;;
    window.location.reload(true);
    // window.location.reload();
  &#125; else &#123;
    alert(&#39;请手动刷新页面！&#39;);
  &#125;
&#125;
window.addEventListener(&#39;error&#39;, (e) =&gt; &#123;
  const pattern = /Loading chunk (\d)+ failed/g;
  const isChunkLoadFailed = error.message.match(pattern);
  // const isChunkLoadFailed =  /Loading chunk [\d]+ failed/.test(e.message)
  if (isChunkLoadFailed) forceRefresh();
  // const targetPath = router.history.pending.fullPath;
  // if (isChunkLoadFailed) router.replace(targetPath);
&#125;);
</code></pre>
<ul>
<li><p><strong>方案 2</strong>：构建时静态资源路径带上版本信息</p>
<ul>
<li>如路径中携带，如原来请求<code>/static/js/balabal.[hash].js</code>，现在<code>/[version]/static/balabal.[hash].js</code></li>
</ul>
</li>
<li><p><strong>方案 3</strong>:增加配置让页面每次加载新数据而不是走缓存,同时让后端帮忙修改 Nginx,设置 no-cache,让页面不要每次去读取缓存</p>
</li>
</ul>
<pre><code class="html">&lt;!-- React 入口文件添加配置让页面每次加载新数据而不是走缓存, --&gt;
&lt;meta http-equiv=&quot;Cache-control&quot; content=&quot;no-cache&quot; /&gt;
&lt;meta http-equiv=&quot;Cache&quot; content=&quot;no-cache&quot; /&gt;
</code></pre>
<ul>
<li><strong>方案 4</strong>:尝试入口文件 client\index.tsx 处进行热更新</li>
</ul>
<pre><code class="js">declare const module: any
if (process.env.NODE_ENV === &#39;development&#39; &amp;&amp; module.hot) &#123;
  module.hot.accept(&#39;./app&#39;, () =&gt; &#123;
    location.reload()
  &#125;)
&#125;
</code></pre>
<ul>
<li><p><strong>方案 5（使用 Umi 框架的项目）</strong></p>
<ul>
<li>1.<code>将 .umirc.js 中的 publicPath 配置成 / </code></li>
<li>2.如果构建的 dist 文件多加一层目录 base</li>
</ul>
<pre><code class="shell">location /base &#123;
  # 用于配合 browserHistory使用
  try_files $uri $uri/ /index.html;
&#125;
</code></pre>
</li>
<li><p><strong>方案 6</strong><br>找到 public&#x2F;index.html 页面,在脚本上 src 前加上”&#x2F;“</p>
</li>
</ul>
<pre><code class="html">&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ul>
<li><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/error-boundaries.html">react 错误边界</a><ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000030686302">https://segmentfault.com/a/1190000030686302</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904047313420295">https://juejin.cn/post/6844904047313420295</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021575442">https://segmentfault.com/a/1190000021575442</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903983786524680">https://juejin.cn/post/6844903983786524680</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/59932119/react-hooks-equivalent-of-componentdidcatch">https://stackoverflow.com/questions/59932119/react-hooks-equivalent-of-componentdidcatch</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/x-orpheus/catch-react-error">网易开源库</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/nuxt/nuxt.js/issues/742">GitHub 讨论</a></li>
</ul>
<h2 id="React-Lazy-的原理"><a href="#React-Lazy-的原理" class="headerlink" title="React.Lazy 的原理"></a>React.Lazy 的原理</h2><pre><code>lazyComponent is not a component but a function that returns a promise object. Inside of the promise that we return from componentLoader, we trigger the function (lazyComponent) and add handlers for promise resolve (.then) and reject(.catch). Since the successful resolution of promise is not a problem in our use case, we let React.lazy handle the resolved contents.
</code></pre>
<pre><code class="js">function componentLoader(lazyComponent) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    lazyComponent()
      .then(resolve)
      .catch((error) =&gt; &#123;
        // let us retry after 1500 ms
        setTimeout(() =&gt; &#123;
          // call componentLoader again!
          if (attemptsLeft === 1) &#123;
            reject(error);
            return;
          &#125;
          componentLoader(lazyComponent, attemptsLeft - 1).then(
            resolve,
            reject
          );
          // add one line to make it all work
        &#125;, 1500);
      &#125;);
  &#125;);
&#125;
</code></pre>
<p><strong>封装 retry 方法</strong></p>
<pre><code class="js"> function retry(
  fn: () =&gt; Promise&lt;&#123;
    default: React.ComponentType&lt;any&gt;;
  &#125;&gt;,
  retriesLeft = 100,
  interval = 1000
) &#123;
  return new Promise&lt;&#123;
    default: React.ComponentType&lt;any&gt;;
  &#125;&gt;((resolve, reject) =&gt; &#123;
    fn()
      .then(resolve)
      .catch((error: any) =&gt; &#123;
        setTimeout(() =&gt; &#123;
          if (retriesLeft === 1) &#123;
            reject(error);
            return;
          &#125;
          retry(fn, retriesLeft - 1, interval).then(resolve, reject);
        &#125;, interval);
      &#125;);
  &#125;);
&#125;
component: lazy(() =&gt; retry(() =&gt; import(&quot;./pages/dashboard/Dashboard&quot;)))
</code></pre>
<!-- ## 运营商的数据拦截 -->
<!-- // webpack动态加载原理(webpack动态加载分片的精简过后的源码)
var promise = new Promise(function (resolve, reject) {
  installedChunkData = installedChunks[chunkId] = [resolve, reject];
});
// 创建scrpit标签，再将其插入到页面上，用来在加载分片的代码
var script = document.createElement("script");
var onScriptComplete;
script.src = jsonpScriptSrc(chunkId);
onScriptComplete = function (event) {
  // installedChunks[chunkId]的值变为0，代表加载成功
  var chunk = installedChunks[chunkId];
  // 判断 installedChunks[chunkId]是否加载成功或失败
  if (chunk !== 0) {
    // 如果还是一个promise则说明加载失败
    // 失败的报错信息可能有两种，
    // - 网络原因(服务器没有这个脚本，或执行报错)：loading chunk x failed.(error http://xxxx.xx.xx/xxx.js)
    // - 数据劫持：loading chunk x failed.(missing http://xxxx.xx.xx/xxx.js)
    if (chunk) {
      var errorType = event && (event.type === "load" ? "missing" : event.type);
      var realSrc = event && event.target && event.target.src;
      var error = new Error(
        "Loading chunk " +
          chunkId +
          " failed.\n(" +
          errorType +
          ": " +
          realSrc +
          ")"
      );
      error.type = errorType;
      error.request = realSrc;
      chunk[1](error);
    }
    installedChunks[chunkId] = undefined;
  }
};
// 给script标签绑定onload/onerror事件的回调函数
script.onerror = script.onload = onScriptComplete;
document.head.appendChild(script);
/*
nstalledChunks[chunkId]的值可能有：
undefined 未加载
null 已经预加载
promise 正在加载
0 已经加载


script引入的代码执行完了之后才会触发onload
webpack动态加载分片顺序：
- 标记installedChunks[chunkId] = [resolve, reject]为正在加载；
- 创建script标签，从服务器加载分片；
- 加载完分片代码后立即执行webpackJsonpCallback修改installedChunks[chunkId] = 0，并执行installedChunks[chunkId][0]的resolve
- 执行完分片代码后，执行script的onload回调函数。判断是否加载成功，如果installedChunks[chunkId] === 0则加载成功，如果installedChunks[chunkId] === [resolve, reject]则加载失败，报错loading chunk x failed.(missing http://xxxx.xx.xx/xxx.js)
*/
 -->

            <hr>
          </div>
          <br>
          <div>
            
              <p>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/%E5%89%8D%E7%AB%AF">前端</a>
                  &nbsp;
                
              </p>
            
            <p>
              <i class="iconfont icon-tag"></i>
              
                <a class="hover-with-bg" href="/tags/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E">编程之美</a>
              
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>
    
  </div>
</footer>

<!-- SCRIPTS -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/popper/popper.min.js"></script>


<script src="/lib/bootstrap/js/bootstrap.min.js"></script>


<script src="/lib/mdbootstrap/js/mdb.min.js"></script>


<script src="/js/main.js"></script>


  
    
<script src="/lib/tocbot/tocbot.min.js"></script>

  
  
<script src="/js/post.js"></script>



  
<script src="/lib/prettify/prettify.min.js"></script>

  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint linenums');
      prettyPrint();
    })
  </script>


  
<script src="/lib/typed/typed.min.js"></script>

  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Loading chunk {n} failed 的解决方法&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>


  
<script src="/lib/anchor/anchor.min.js"></script>

  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  
<script src="/js/local-search.js"></script>

  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>


</body>
</html>
