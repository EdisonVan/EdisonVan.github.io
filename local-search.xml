<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>企业管理项目权限管控设计</title>
    <link href="undefined2022/05/10/permission_list/"/>
    <url>2022/05/10/permission_list/</url>
    
    <content type="html"><![CDATA[<h1 id="根据-moduleId-返回模块级权限树"><a href="#根据-moduleId-返回模块级权限树" class="headerlink" title="根据 moduleId 返回模块级权限树"></a>根据 moduleId 返回模块级权限树</h1><p><strong>Authorized.ts</strong></p><pre><code class="js">export function fetchPermissionButton(moduleId: string) &#123;  return http.get(`$&#123;urls.LOGINAPI&#125;/Auth/UserInfo`, &#123;    moduleId: moduleId,    systemCode: &#39;DIYCODE&#39;, // 对应系统的Code码  &#125;);&#125;/* 按钮权限，不符合权限不显示 */interface IAuthorized &#123;  src: string[] // 权限数组  moduleId: string // 权限对应的 moduleId&#125;export default function Authorized(props: IAuthorized) &#123;  const &#123; src, moduleId, children &#125; = props  return src.some((item) =&gt; item.moduleId === moduleId) ? children : &#39;&#39;&#125;</code></pre><h1 id="Useage-Code-Snippet"><a href="#Useage-Code-Snippet" class="headerlink" title="Useage Code Snippet"></a>Useage Code Snippet</h1><pre><code class="tsx">const [permissionButton, setPermissionButton] = useState(null);useEffect(() =&gt; &#123;  const moduleId = &#39;YHYWXT_P_00005&#39;; // 页面权限Code  // 预先加载页面按钮权限  fetchPermissionButton(moduleId)    .then((res) =&gt; &#123;      const &#123; isSuccess, result, message &#125; = res.data;      if (isSuccess) &#123;        setPermissionButton(result.privilegeTree);      &#125; else &#123;        message.error(message);      &#125;    &#125;)    .catch((err) =&gt; &#123;      console.log(err);    &#125;);&#125;, []);return (  permissionButton &amp;&amp; (    &lt;Authorized src=&#123;permissionButton&#125; moduleId=&#39;YHYWXT_B_00010&#39;&gt;      &lt;Button size=&#39;small&#39;&gt;添加&lt;/Button&gt;    &lt;/Authorized&gt;  ));</code></pre><!-- TODOreview 实现- react-study/code/code-review/top_pc/client/components/security/index.tsx- react-study/code/code-review/top_pc/client/app.tsx -->]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智能家居</title>
    <link href="undefined2021/12/11/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85/"/>
    <url>2021/12/11/%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85/</url>
    
    <content type="html"><![CDATA[<h1 id="易微联开机卡"><a href="#易微联开机卡" class="headerlink" title="易微联开机卡"></a>易微联开机卡</h1><ul><li><a href="https://www.baiyunxitong.com/bangzhu/5536.html">BIOS 设置关机状态下 USB 接口待机电源方法</a></li></ul><p><strong>易微联开机卡线路连接</strong></p><ul><li>POWER SW 线一端连的开机卡 com 口，一端开机卡 no 口</li></ul><blockquote><p>注意不要把 POWER Light 线当电源线哈~</p></blockquote><p><strong>易微联开机卡配网步骤</strong></p><ul><li>接通电源，如果指示灯快闪三下长亮一下，直接进行第 2 步添加（否则长按 WiFi 配对键 5 秒）</li><li>手机连接 2.4GHz 的 WiFi，打开易微联 App 添加注册 WiFi 设备<ul><li>点击 App 底部 “+”</li><li>选择“快速添加”</li><li>输入路由器密码，确保无误后点击“下一步”</li><li>等待 App 发现设备，按照页面提示完成添加注册</li></ul></li></ul><h2 id="视频参考"><a href="#视频参考" class="headerlink" title="视频参考"></a>视频参考</h2><ul><li><a href="https://www.bilibili.com/video/BV1j7411C7AX?share_source=copy_web">配网视频步骤</a></li><li><a href="https://www.bilibili.com/video/BV1Z7411K7ZZ?share_source=copy_web">易微联使用视频 2</a></li><li><a href="https://www.bilibili.com/video/BV1KA411T7uu?share_source=copy_web">05:15 开始</a></li></ul><h1 id="win11-安装教程"><a href="#win11-安装教程" class="headerlink" title="win11 安装教程"></a>win11 安装教程</h1><ul><li>U 盘灌好 Win11 ISO，从 U 盘引导系统，安装，一直到提示你不符合要求那个界面</li><li>按下 shift+F10，打开 CMD 窗口，输入 regedit，打开注册表编辑器</li><li>找到 HKEY_LOCAL_MACHINE\SYSTEM\Setup 文件夹</li><li>右键，新建“项”，名称为 LabConfig</li><li>进入到这个新建的文件夹（项）中，右键，新建 dword（32 位），名称为 BypassTPMCheck，值为 1</li><li>（有网友推荐，此步不需要，可省略，你可以试一下）同上，再新建 Dword（32 位），名称为 BypassRAMCheck，值为 1</li><li>再新建 BypassSecureBootCheck（32 位），值为 1</li><li>完成上述 1 个项和 3 个键值的建立和设定后，关闭注册表编辑器，关闭 CMD 窗口，回到报错窗口，返回上一步（左上角按钮），重新执行安装，此时你会发现可以顺利装下去了。</li></ul><p><strong>转换磁盘格式</strong></p><ul><li>在当前安装界面按住 Shift+F10 调出命令提示符窗口；</li><li>输入“diskpart”，按回车执行，进入 DISKPART 命令模式；</li><li>输入“list disk”回车，列出当前磁盘信息；</li><li>输入“select disk 0”回车，选中磁盘 0；</li><li>输入“clean”，删除磁盘分区；</li><li>输入“convert mbr”，回车，将磁盘转换为 MBR，或者，输入“convert gpt”将磁盘转换为 GPT；</li><li>输入“exit”，回车，退出 DISKPART 命令模式，再次输入“exit”，回车，退出命令提示符，返回安装界面继续安装系统</li></ul>]]></content>
    
    
    <categories>
      
      <category>DIY</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>山地车组装</title>
    <link href="undefined2021/08/22/DIY/"/>
    <url>2021/08/22/DIY/</url>
    
    <content type="html"><![CDATA[<blockquote><p>16 年的烈风马丁改装升级，原车陪我在大学游历了诸多风景，希望升级后陪堂弟在大学度过美好时光</p></blockquote><h1 id="山地车结构分析"><a href="#山地车结构分析" class="headerlink" title="山地车结构分析"></a>山地车结构分析</h1><p>龙头加垫片<br>压线螺丝替换<br>尾钩替换<br>前后变速器调整；<a href="https://haokan.baidu.com/v?pd=bjh&amp;type=video&amp;vid=16146343645818591916">https://haokan.baidu.com/v?pd=bjh&amp;type=video&amp;vid=16146343645818591916</a><br>打气<br>加油</p><table><thead><tr><th>零件清单名称</th><th>新车</th><th>旧车</th></tr></thead><tbody><tr><td>车架（15 寸）</td><td>碳纤维 1599</td><td>旧车</td></tr><tr><td>轮组（26 寸）</td><td>RXR 轮组 碳纤维 368</td><td>旧车</td></tr><tr><td>前叉碗组碳纤垫圈</td><td>12.02</td><td></td></tr><tr><td>SUNSHINE 日晖飞轮 9 速 32T</td><td>43</td><td></td></tr><tr><td>牙盘曲柄</td><td>70</td><td></td></tr><tr><td>脚踏板</td><td>培林脚踏 磁性自吸脚撑 99</td><td>旧车</td></tr><tr><td>前变速器（前拨）</td><td>禧玛诺 M8020 165</td><td>旧车</td></tr><tr><td>后变速器</td><td>旧车</td><td>🚀 待购</td></tr><tr><td>前牙盘（车中间位置，脚踏板处）</td><td>两个盘 99</td><td>旧车（三个盘）</td></tr><tr><td>车把</td><td>旧车</td><td>🚀 待购</td></tr><tr><td>刹车把手（左、右）</td><td>旧车</td><td>🚀 待购</td></tr><tr><td>前刹</td><td>旧车</td><td>🚀 待购</td></tr><tr><td>后刹</td><td>旧车</td><td>🚀 待购</td></tr><tr><td>刹车皮（来令片）</td><td>马丁 T+mt2 金属一套 27</td><td>🚀 待购 2 套</td></tr><tr><td>后轮固定方式</td><td>桶轴固定杆</td><td>快拆杆</td></tr><tr><td>刹车碟片（不能涂油）</td><td>G3 碟片两张 28</td><td>旧车</td></tr><tr><td>线管</td><td>外线 2 米（前后变速线 6）、刹车是油管，不需要去买单独的线</td><td>旧车</td></tr><tr><td>变速内线</td><td>TRLREQ 刹车线变速线内线 2 根（前后变速线 15+17）</td><td>🚀 待购</td></tr><tr><td>脚撑</td><td>碳纤维车架不能使用，通过脚踏板停靠</td><td>旧车</td></tr><tr><td>后货架</td><td>碳纤维车架不能使用</td><td>旧车</td></tr><tr><td>链条</td><td>魔术卡扣</td><td>🚀 待购</td></tr><tr><td>垫圈（前叉碗组）</td><td>烈风</td><td>🚀 待购</td></tr><tr><td>车座位杆、车座</td><td>旧车</td><td>🚀 待购</td></tr><tr><td>内胎</td><td>旧车 + 朝阳内胎 16</td><td>正新内胎</td></tr><tr><td>外胎</td><td>旧车</td><td>🚀 待购</td></tr><tr><td>中轴</td><td>禧玛诺 BB71 150</td><td>旧车</td></tr><tr><td>立管</td><td></td><td></td></tr><tr><td>车座管</td><td></td><td></td></tr><tr><td>燕把</td><td></td><td></td></tr><tr><td>坐垫</td><td></td><td></td></tr><tr><td>把套</td><td></td><td></td></tr><tr><td>垫片</td><td></td><td></td></tr></tbody></table><h1 id="装车工具"><a href="#装车工具" class="headerlink" title="装车工具"></a>装车工具</h1><ul><li>润滑油（清晰的链条油可以上链条和飞轮上）</li><li>拧轴通的工具（如果商家没帮装中轴）</li><li>黄油（固体油只是上轴承里面）</li><li>六毫米内六角工具</li><li>中轴拆卸工具</li><li>组合工具</li><li>停车架</li><li>橡胶锤</li></ul><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>碳纤维车架，缺点承重较差，不能用支撑后货架、载物后架</li></ul><h1 id="前叉"><a href="#前叉" class="headerlink" title="前叉"></a>前叉</h1><p>装好腕组 然后插入前叉 最好安装好垫圈 锁紧把立<br>前叉底部（车架下方）垫片顺序，大的放到下方，小的放上面</p><ul><li>前叉垫片顺序 1</li><li>前叉垫片顺序 2</li><li>前叉垫片顺序 3</li><li>前叉（腕组）固定圈.JPG</li></ul><p>白色得大圈，放车架下面头管下</p><ul><li>车驾车头底部垫片.jpg</li><li>车驾车头底部垫片装后.JPG</li></ul><p>装新车架，注意如果前叉之前有底挡，需要用一个平口螺丝刀把它给砸下来，把它取下来换新的</p><ul><li>前叉之前的底挡.jpg</li></ul><h2 id="立垫圈"><a href="#立垫圈" class="headerlink" title="立垫圈"></a>立垫圈</h2><p>立垫圈：垫高把立的</p><h1 id="中轴"><a href="#中轴" class="headerlink" title="中轴"></a>中轴</h1><ul><li>用一个中轴拆卸工具，把这个塑料盖拆掉<br>中轴拆卸.JPG</li></ul><p>橡胶锤敲击，拿下来牙盘<br>取牙盘.JPG</p><h2 id="变速器"><a href="#变速器" class="headerlink" title="变速器"></a>变速器</h2><ul><li>要穿线，这个是线管，我给你配的是正好的线管，穿到车架里面，以变速线的</li></ul><h2 id="QA：车轮毂前后轮区分，看标志或者纹路，后轮带花鼓"><a href="#QA：车轮毂前后轮区分，看标志或者纹路，后轮带花鼓" class="headerlink" title="QA：车轮毂前后轮区分，看标志或者纹路，后轮带花鼓"></a>QA：车轮毂前后轮区分，看标志或者纹路，后轮带花鼓</h2><ul><li>后轮花鼓.jpg</li></ul><h2 id="QA：26-和-27-5-的轮毂使用上有啥区别？"><a href="#QA：26-和-27-5-的轮毂使用上有啥区别？" class="headerlink" title="QA：26 和 27.5 的轮毂使用上有啥区别？"></a>QA：26 和 27.5 的轮毂使用上有啥区别？</h2><ul><li>27.5 的，稍微大一点，更加稳定</li></ul><h2 id="QA：中轴要适合车架，适合车架才能装牙盘"><a href="#QA：中轴要适合车架，适合车架才能装牙盘" class="headerlink" title="QA：中轴要适合车架，适合车架才能装牙盘"></a>QA：中轴要适合车架，适合车架才能装牙盘</h2><h2 id="QA：中轴可以让淘宝店提前装好，自己装需要专业工具"><a href="#QA：中轴可以让淘宝店提前装好，自己装需要专业工具" class="headerlink" title="QA：中轴可以让淘宝店提前装好，自己装需要专业工具"></a>QA：中轴可以让淘宝店提前装好，自己装需要专业工具</h2><h2 id="QA：变速器我换档位好像没反应，是线有点松"><a href="#QA：变速器我换档位好像没反应，是线有点松" class="headerlink" title="QA：变速器我换档位好像没反应，是线有点松"></a>QA：变速器我换档位好像没反应，是线有点松</h2><h1 id="变速器调节注意事项"><a href="#变速器调节注意事项" class="headerlink" title="变速器调节注意事项"></a>变速器调节注意事项</h1><p>右侧变速，变速起来会有咯吱咯吱响，一般是指拨缺油或者链条飞轮问题</p><h1 id="山地车升级（碳纤维车架-配件）"><a href="#山地车升级（碳纤维车架-配件）" class="headerlink" title="山地车升级（碳纤维车架+配件）"></a>山地车升级（碳纤维车架+配件）</h1><h1 id="山地车装车视频"><a href="#山地车装车视频" class="headerlink" title="山地车装车视频"></a><a href="http://mp.weixin.qq.com/s?__biz=MzA3Njg1MTExOA==&mid=206624082&idx=3&sn=443d3070766e7bf82251d36a88b4d634&scene=4#wechat_redirec">山地车装车视频</a></h1><ul><li>脚踏分左右的，脚踏轴上有标注 L 是左侧 R 是右侧，左侧是逆时针拧，右侧是顺时针拧，都是往前轮方向按，这个很重要切记一定要拧紧，不拧紧不行</li><li>脚踏没有装紧会导致脚踏和曲柄之间有一定的间隙在反复踩踏的过程中间隙扩大导致脚踏掉曲柄丝坏</li><li>脚踏分左右 LR 代表左右。因为脚踏是刚轴曲柄丝铝合金的。脚踏没有装紧的情况下受伤的就是曲柄</li></ul><h1 id="装车视频"><a href="#装车视频" class="headerlink" title="装车视频"></a><a href="https://www.bilibili.com/video/BV1es411h7Ac?from=search&seid=7978313182495598482">装车视频</a></h1><h1 id="山地车组装"><a href="#山地车组装" class="headerlink" title="山地车组装"></a>山地车组装</h1><p>old-首图 1.JPG</p><p><a href="https://mp.weixin.qq.com/s/GtTL0ILJhreLkmRqk7O6sQ">https://mp.weixin.qq.com/s/GtTL0ILJhreLkmRqk7O6sQ</a></p><ul><li>固定轮子带替之前的快拆杆</li></ul><p>碟片不能涂油</p><p>原来车子的后货架就不能再再用，碳纤维车架，高端的不能用支撑后货架等等</p><p>牙盘你用两个盘把你原来的一个盘拆掉（装脚踏的那）</p><p>前后变速线内线（两根）<br>外线（2 米）<br>刹车是油管，不需要去买单独的线</p><p>黄油按固体油只是上轴承里面<br>清晰的链条油可以上链条和飞轮上</p><p>山地车组装零件<br>修山地车（搞清楚配件明细）、碟刹</p><h2 id="刹车器"><a href="#刹车器" class="headerlink" title="刹车器"></a>刹车器</h2><p>如果空捏刹车，刹车片会贴合，此时用平口螺丝刀撬大间隙就行，不然骑行过程碟片会与刹车盘有摩擦<br>刹车器.JPG<br>刹车器 2.JPG</p><p>刹车线外走油管</p><h2 id="变速器走线"><a href="#变速器走线" class="headerlink" title="变速器走线"></a>变速器走线</h2><ul><li>变速器压线螺丝松掉，可以拉出来</li><li>变速器我们说的是后变速器和前垫速器，不要去动指拨</li></ul><h2 id="前变速器"><a href="#前变速器" class="headerlink" title="前变速器"></a>前变速器</h2><ul><li>安装后测试：脚踏板齿轮，看一下齿轮是否会蹭到车身，有些车架只需要两个轮盘；</li><li>旧车前变速器.jpg</li></ul><h2 id="后轮齿"><a href="#后轮齿" class="headerlink" title="后轮齿"></a>后轮齿</h2><p>后轮齿.jpg<br>后轮齿轮拆装方法.JPG</p><h1 id="桶轴杆"><a href="#桶轴杆" class="headerlink" title="桶轴杆"></a>桶轴杆</h1><p>长的杆子是是桶轴杆：把轮子固定到车架上（固定后轮）<br>轮组安装到车架上，它是有桶轴的，桶轴直接拧上，需要一个六毫米内六角工具<br>轮组.HEIC</p><p>车头.HEIC</p><p>桶轴杆装好后，桶轴白色垫片放这一端就行<br>桶轴白色垫片.jpg</p><p>桶轴盖子，小的放塔基，大的放碟片，直接盖</p><ul><li>桶轴盖子.jpg</li></ul><h2 id="链条拆卸"><a href="#链条拆卸" class="headerlink" title="链条拆卸"></a>链条拆卸</h2><ul><li>链条，有魔术裤，有魔术扣，就需要用这个钳子，没有就要用截链器</li><li>找到魔术扣的地方，把链条栓口捅出来</li><li><img src="/%E9%93%BE%E6%9D%A1%E6%8B%86%E5%8D%B81.jpeg" alt="1"></li></ul><p><img src="/%E8%9E%BA%E4%B8%9D%E5%9B%BA%E5%AE%9A%E5%89%8D%E5%8F%98%E9%80%9F%E5%99%A8%E4%BD%BF%E7%94%A8.JPG" alt="螺丝固定前变速器使用"><br><strong>png</strong><br>螺丝固定前变速器使用-1</p><ul><li>左边是固定花芯</li><li>右边的固定前变速器</li></ul><p>螺丝固定前变速器使用-2<br>前变速器固定位置.JPG<br>固定后轮使用.JPG</p><h1 id="后变速器安装"><a href="#后变速器安装" class="headerlink" title="后变速器安装"></a>后变速器安装</h1><ul><li>拆卸：先把压线螺丝松开，变速器就可以下下来，变速器和尾钩之间有个固定螺丝，松开，钢丝线和变速器之间有一个颜色的线帽，把它给拿下来</li></ul><p>变速器和尾勾之间固定螺丝，压线螺丝紧住，钢丝线和变速器之间夹紧一个线帽<br>old-后变速器-1<br>old-后变速器-2<br>old-后变速器-2</p><p>替换原来刹车龙头这个线，装完以后将线，线在固定到变速器压线螺丝那，超长的线剪断后，套好套一个铝合金线帽，夹紧<br>线和管子.jpg<br>后刹线固定.jpg<br>后刹线固定 1.jpg<br>前刹线固定.jpg</p><p>车把手，左边变速是前变速器，右边是右边速器</p><h1 id="前叉锁-jpg"><a href="#前叉锁-jpg" class="headerlink" title="前叉锁.jpg"></a>前叉锁.jpg</h1><ul><li>前叉锁.jpg</li><li>微信对话视频</li></ul><h1 id="其他零件"><a href="#其他零件" class="headerlink" title="其他零件"></a>其他零件</h1><p>其他零件-轮组.HEIC<br>其他零件-车架.HEIC<br>备用辐条</p><h1 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h1><p>后轮刹车片和碟片紧贴在一起，需要怎么来调节一下？<br>线过长，待整理<br>线过长.JPG<br>新车-end.JPG<br>指拨缺油<br>链条飞轮问题</p><h1 id="关于公路车"><a href="#关于公路车" class="headerlink" title="关于公路车"></a>关于公路车</h1><ul><li>公路车推荐使用弯把，直把更适合休闲公路骑行</li></ul><h1 id="待购"><a href="#待购" class="headerlink" title="待购"></a>待购</h1><!-- 旧车数据：烈风、马丁、30速、蓝白15寸、26英寸 --><!--朋友圈两个周末，在两个弟弟的齐力帮助下，DIY了一辆新车～ -->]]></content>
    
    
    <categories>
      
      <category>骑行趣事</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Charles使用记录</title>
    <link href="undefined2021/05/16/Charles%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>2021/05/16/Charles%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Charles-手机抓包设置"><a href="#Charles-手机抓包设置" class="headerlink" title="Charles 手机抓包设置"></a>Charles 手机抓包设置</h1><ul><li>常用：copy 别人网站图片或脚本</li><li>原理：手机依靠 charles 与服务端进行对话</li><li>目标：把手机的网络委托给 charles 进行代理</li><li>手机抓包设置流程总结（类似 HTTP 的握手原理，双方保证正常通信即可）<ul><li>1.在 charles 里设置允许手机联网的权限；把 charles 设置为允许的状态并设置允许的端口号，这样手机端才能正常的接入</li><li>2.把手机按照 charles 的 IP 和端口进行配置</li><li>3.手机配对成功后，charles 还会弹窗是否允许（charles 虽然开放了端口，但并不知道是哪一台手机会配入，此窗口起到提示和安全防护的作用）</li></ul></li></ul><h1 id="Charles-使用教程"><a href="#Charles-使用教程" class="headerlink" title="Charles 使用教程"></a>Charles 使用教程</h1><p><strong>1.设置 charles 为允许状态，并设置好接入端口</strong><br>在 Charles 的菜单栏上选择“Proxy”-&gt;“Proxy Settings”，填入任意代理<code>端口号</code>，如 8888（记住这个端口，因为这里设置的允许接入的端口，手机端配置时需要用到），并且勾上”Enable transparent HTTP proxying” 就完成了在 Charles 上的设置。<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/charles_setting.png?raw=true"><br>在 charles 点击 HELP -&gt; local IP Address 看到当前的<code>*本机 IP 地址*</code><br><img src="https://github.com/EdisonVan/GraphBed/raw/master/charles_location_20210516.png?raw=true"><br>charles 允许手机接入的 IP 和端口是<code>IP地址:端口号</code>，如 192.168.1.107:8888<br>手动在浏览器中输入<code>IP地址:端口号</code>，会发现 charles 会提示一个窗口问你是否允许接入；<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/charles_connect_20210516.png?raw=true"></p><p><strong>2.把手机按照 charles 的 IP 和端口进行配置</strong><br>手机连接<code>Wi-Fi</code>，电脑和手机连接同一个<code>Wi-Fi</code><br>在 iPhone 的 “设置”-&gt;“无线局域网“中，可以看到当前连接的<code>Wi-Fi</code>名，通过点击右边的详情键，在其最底部有<code>Configure Proxy/配置代理</code>一项，将其切换成手动，然后填上 Charles 运行所在的电脑的 IP，及端口号 8888<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/charles_iphone_set.jpg?raw=true"><br>设置好之后，打开 iPhone 上的任意需要网络通讯的程序，可以看到 Charles 弹出 iPhone 请求连接的确认菜单，点击允许<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/charles_iphone_connect_210516.png?raw=true"></p><p><strong>3.手机配对成功后，就可以电脑上就抓到访问的资源了</strong><br><img src="https://github.com/EdisonVan/GraphBed/raw/master/digiwin_charles.png?raw=true" alt="1"><br>拷贝对应路径的 url，然后在浏览器中输入 url 回车即可看到对应页面</p><!-- 比如此时，访问企业微信或 pengsifan.com --><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ul><li><a href="http://www.cnblogs.com/jiayuchn-test/p/8875105.html">更详细的 Charles 操作</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>快乐编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021会有哪些不一样？</title>
    <link href="undefined2021/02/07/2021%E4%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9F/"/>
    <url>2021/02/07/2021%E4%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2020 对于我来说是很奇幻的一年，工作换了 2 份，认知也得到了大幅提升。不过我始终坚信狼叔说过的那句话，少抱怨多思考，明天会更好！</p></blockquote><p><img src="https://i.loli.net/2021/02/10/NujsVEt53ZgaGHR.jpg" alt="Ctrip"></p><h1 id="GoodBye-2020"><a href="#GoodBye-2020" class="headerlink" title="GoodBye 2020"></a>GoodBye 2020</h1><p>上半年受疫情影响，我在的公司是做租车业务，普调被取消，晋升被延期，组内陆续有同事跳槽；直到组内最好的朋友申请了降薪回老家远程办公。于是我在 5 月中旬开始了请假面试，陆续拿到了几个 offer，我跟组长和广哥提了离职后，选择 6 月初入职携程，而这个决定改变了我过往的一些价值观。10 月份离职告别 996，这次严谨的对比了 offer 后加入了 miHoYo！年会原以为自己是阳光普照，却中了台顶配 iPhone12 Pro Max！😂</p><blockquote><p>初入社会还是不太习惯分别，离职的这天请组内小伙伴在长风大悦城搓了一顿，心里满是感激和不舍！</p></blockquote><p><img src="https://i.loli.net/2021/02/10/1CQ5YLz62HySuWh.jpg" alt="eHi"></p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul><li>react 项目全面使用 hooks+ts</li><li>开始使用 Jest 进行前端单测，但还是停留在使用层面，一些边界条件考虑的还不够</li><li>动手搭建了 pc 端的通用脚手架，得到了组长的一些指点，进一步思考可视化搭建中…</li><li>重新用上了 vue 写 h5，学会了更多的关注不同业务适合什么技术栈，而不是去纠结哪个技术栈自己使用更熟练</li><li>代码更规范了，会习惯性的抽离通用组件，并对代码进行拆分，每个 tsx 文件代码量尽可能地控制在了 300 行以内</li></ul><h2 id="认知"><a href="#认知" class="headerlink" title="认知"></a>认知</h2><ul><li>始终感激身边每一个人</li><li>摒弃学生思维，逢人话三分，交浅不言深</li><li>能给团队带来的价值以及自己的成长才是核心竞争力</li><li>不去阴谋论任何一个人，但如果发现某些人作风不良，私下交谈的场合一定要录音</li></ul><p><img src="https://i.loli.net/2021/02/10/UOP34kaIFXBbLeN.jpg" alt="Ctrip"></p><h1 id="Hello-2021"><a href="#Hello-2021" class="headerlink" title="Hello 2021"></a>Hello 2021</h1><h2 id="没有-Flag-就没有灵魂"><a href="#没有-Flag-就没有灵魂" class="headerlink" title="没有 Flag 就没有灵魂"></a>没有 Flag 就没有灵魂</h2><ul><li>快乐工作，准点下班</li><li>重构 Blog(React+Ts+Less+Golang)</li><li>Golang 学习<ul><li><input disabled="" type="checkbox"> Go 语言从入门到实战-极客时间</li><li><input disabled="" type="checkbox"> 《Go 语言编程之旅》</li><li><input disabled="" type="checkbox"> 参与一个 Go 语言项目</li></ul></li><li>明确职业规划</li><li>治愈拖延症<ul><li>每月坚持阅读 2 本书</li><li>每周坚持写一篇博客</li></ul></li><li>学着和各类人博弈，而不是一味地接受</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mock方案</title>
    <link href="undefined2021/01/05/Mock%E6%96%B9%E6%A1%88/"/>
    <url>2021/01/05/Mock%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><ul><li>1.<code>JSON-server + express</code></li><li>2.<code>Yapi + mock.js</code></li><li>3.Vue-cli 使用 json server 在本地模拟请求数据</li></ul><h1 id="项目中使用-JSON-server-方法"><a href="#项目中使用-JSON-server-方法" class="headerlink" title="项目中使用 JSON-server 方法"></a>项目中使用 JSON-server 方法</h1><p><code>npm install json-server --save</code></p><pre><code class="js">var jsonServer = require(&quot;json-server&quot;); // 引入jsonServervar jsonServer = new jsonServer(); // 实例化jsonServervar apiRouter = express.Router();var fs = require(&quot;fs&quot;);apiRouter.route(&quot;/:apiName&quot;).all(function (req, res) &#123;  fs.readFile(&quot;./db.json&quot;, &quot;utf8&quot;, function (err, data) &#123;    if (err) throw err;    var data = JSON.parse(data);    if (data[req.params.apiName]) &#123;      res.json(data[req.params.apiName]);    &#125; else &#123;      res.send(&quot;no such api name&quot;);    &#125;  &#125;);&#125;);</code></pre><blockquote><p>db.json 是当前访问页面的同级目录下的 json</p></blockquote><h2 id="json-server-使用方法官方简单例简介"><a href="#json-server-使用方法官方简单例简介" class="headerlink" title="json-server 使用方法官方简单例简介"></a>json-server 使用方法官方简单例简介</h2><pre><code class="js">var jsonServer = require(&quot;json-server&quot;); // 引入var Server = jsonServer.create(); // 搭建servervar Router = jsonServer.router(&quot;db.json&quot;); // 关联自己的db数据var middlewares = jsonServer.defaults();Server.use(middlewares);Server.use(router);server.listen(3000, function () &#123;  监听端口;  console.log(&quot;JSON Server is running&quot;);&#125;);</code></pre><h2 id="测试服务器的模拟搭建和使用"><a href="#测试服务器的模拟搭建和使用" class="headerlink" title="测试服务器的模拟搭建和使用"></a>测试服务器的模拟搭建和使用</h2><p>案例：json-server 搭建之后在组件中调用</p><pre><code class="js">export default &#123;  created: function () &#123;    this.$http      .post(&quot;api/getNewsList&quot;) // 调用api下的getNewsList方法      .then(        function (res) &#123;          console.log(res.data); // res.data就是拿到的数据        &#125;,        function (err) &#123;          console.log(err);        &#125;      );  &#125;,&#125;;</code></pre><p>打开控制台，console 里面能到成功的回调数据<br>Network 中的 XHR 中能看到 getNewList 发送了一个 POST 请求</p><h1 id="使用-JSON-Server-搭建-Mock-服务器"><a href="#使用-JSON-Server-搭建-Mock-服务器" class="headerlink" title="使用 JSON Server 搭建 Mock 服务器"></a>使用 JSON Server 搭建 Mock 服务器</h1><p>vue-cli-mock<br>vue-cli 添加本地 mock 服务框架</p><pre><code class="bash">npm install   //install dependenciesnpm run dev   //serve with hot reload at localhost:8080npm run build   //build for production with minificationnpm run mock    //run mock serve localhost:3000npm run mockdev   //run serve with mock serve</code></pre><p>mock 目录</p><pre><code class="bash">└── mock/         # mock配置目录    └── db.json         # mock数据配置    └── faker-data.js     # 批量生成伪数据    └── post-to-get.js      # post映射为get中间件</code></pre><blockquote><p><a href="https://github.com/typicode/json-server">JSON Server</a>是一个创建伪 RESTful 服务器的工具</p></blockquote><p><strong>db.json</strong></p><pre><code>&#123;  &quot;posts&quot;: [&#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125;],  &quot;comments&quot;: [&#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125;],  &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;&#125;</code></pre><p>在 vue-cli 中的用法<br>配置流程</p><pre><code class="bash">npm install -g json-server #全局安装</code></pre><p><strong>package.json</strong>添加命令</p><pre><code class="json">&quot;mock&quot;: &quot;json-server --watch mock/db.json&quot;,&quot;mockdev&quot;: &quot;npm run mock &amp; npm run dev&quot;</code></pre><h2 id="启动-mock-服务器"><a href="#启动-mock-服务器" class="headerlink" title="启动 mock 服务器"></a>启动 mock 服务器</h2><p><code>npm run mock</code>命令运行 mock server 访问<code>http://localhost:3000/</code>发现<code>db.json</code>下第一级 <code>json对象</code>被解析成为可访问路径<br>GET 请求具体路径 如：<a href="http://localhost:3000/posts">http://localhost:3000/posts</a> 可获取数据</p><h2 id="faker-js批量生成伪数据"><a href="#faker-js批量生成伪数据" class="headerlink" title="faker.js批量生成伪数据"></a><a href="https://github.com/Marak/faker.js">faker.js</a>批量生成伪数据</h2><pre><code class="bash">cnpm install faker -G #全局安装 faker</code></pre><pre><code class="js">module.exports = function () &#123;  var faker = require(&quot;faker&quot;);  faker.locale = &quot;zh_CN&quot;;  var _ = require(&quot;lodash&quot;);  return &#123;    people: _.times(100, function (n) &#123;      return &#123;        id: n,        name: faker.name.findName(),        avatar: faker.internet.avatar(),      &#125;;    &#125;),    address: _.times(100, function (n) &#123;      return &#123;        id: faker.random.uuid(),        city: faker.address.city(),        county: faker.address.county(),      &#125;;    &#125;),  &#125;;&#125;;</code></pre><p><code>json-server mock/faker-data.js</code>：在 json server 中使用 faker 请求，<code>http://localhost:3000/address</code>可获取到随机生成的 100 组伪数据</p><h2 id="添加中间件"><a href="#添加中间件" class="headerlink" title="添加中间件"></a>添加中间件</h2><p><code>json server</code>使用 RESTful 架构，GET 请求可以获取数据，POST 请求则是添加数据。<br>开发过程中想直接模拟获取 POST 请求返回结果，可添加 express 中间件将 POST 请求转为 GET 请求<br><strong>post-to-get.js</strong></p><pre><code class="js">module.exports = function (req, res, next) &#123;  req.method = &quot;GET&quot;;  next();&#125;;</code></pre><p><strong>package.json</strong>启动命令添加运行中间件</p><pre><code class="json">&quot;mock&quot;: &quot;json-server --watch mock/db.json --m mock/post-to-get.js&quot;</code></pre><p>重新启动服务，POST 请求就被转换为 GET 请求了</p><blockquote><p>其他需求也可以通过添加不同的中间件实现</p></blockquote><h2 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h2><p><code>config/index.js</code>的 proxyTable 将请求映射到 <a href="http://localhost:3000/">http://localhost:3000</a></p><pre><code class="js">proxyTable:&#123;    &#39;/api/&#39;:&#123;        target:&#39;http://localhost:3000&#39;,        changeOrigin:true,        pathRewrite:&#123;            &#39;^/api&#39;:&#39;&#39;        &#125;    &#125;,&#125;,</code></pre><p>添加请求测试效果</p><pre><code class="js">axios.post(&quot;/api/posts&quot;, &#123;&#125;).then((m) =&gt; console.log(m.data));</code></pre><p><code>npm run mockdev</code>启动带 mock 数据的本地服务</p><h1 id="Vue-cli-使用-json-server-在本地模拟请求数据"><a href="#Vue-cli-使用-json-server-在本地模拟请求数据" class="headerlink" title="Vue-cli 使用 json server 在本地模拟请求数据"></a>Vue-cli 使用 json server 在本地模拟请求数据</h1><p>后台还没给接口之前，使用 JSON-Server 搭建一台 JSON 服务器，将接口要返回的数据放在 json 文件里面 1.安装依赖</p><pre><code class="bash">cnpm install json-server –save #json servercnpm install axios --save #使用axios发送请求</code></pre><p>2.创建 db.json 文件放置在跟 index.html 平级的目录中（如 static 目录）&#x2F;build 文件夹下 3.配置 build&#x2F;dev-server.js</p><pre><code class="js">//json-server 假数据const jsonServer = require(&#39;json-server&#39;) // 引入文件const apiServer = jsonServer.create(); //创建服务器const apiRouter = jsonServer.router(&#39;db.json&#39;) //引入json 文件const middlewares = jsonServer.defaults(); //返回JSON服务器使用的中间件// 监听端口apiServer.use(middlewares)apiServer.use(&#39;/json&#39;,apiRouter)apiServer.listen( port + 1,()=&gt;&#123;    //json服务器端口:比如你使用8080,这里的json服务器就是8081端口    console.log(&#39;JSON Server is running&#39;)    //json server成功运行会在git bash里面打印出&#39;JSON Server is running&#39;&#125;)var uri = ‘http://localhost:’ + portvar _resolvevar readyPromise = new Promise(resolve =&gt;&#123;_resolve = resolve&#125;)</code></pre><p><code>npm run dev</code>启动项目，浏览器输入 localhost:8081，就可以访问到你的 json 文件</p><p>3.服务已启动成功加上相应后缀即可访问文件里面的数据，如<code>localhost:8081/posts</code></p><p>4.请求接口代理&#x2F;浏览器代理设置<br><strong>config&#x2F;index.js</strong></p><pre><code class="js">proxyTable: &#123;  &#39;/api&#39;: &#123;    target: &#39;http://localhost:8081/&#39;,  // 通过本地服务器将你的请求转发到这个地址    changeOrigin: true,  // 设置这个参数可以避免跨域    pathRewrite: &#123;      &#39;/api&#39;: &#39;/&#39;    &#125;  &#125;,&#125;,</code></pre><p>验证</p><p>5.axios 请求 json 数据<br><strong>main.js</strong></p><pre><code class="js">import axios from &quot;axios&quot;;Vue.prototype.$ajax = axios; // 将axios挂载到Vue实例中的$ajax上面,在项目中的任何位置通过this.$ajax使用// 在组件中的使用方式，比如：this.$ajax(&#123;  url: &quot;/api/articles&quot;, //api 代理到json文件地址，后面的后缀是文件中的对象或数组  method: &quot;get&quot;, // 请求方式  // 可添加axios文档中的各种配置&#125;)  .then(function (res) &#123;    console.log(res, &quot;成功&quot;);  &#125;)  .catch(function (err) &#123;    console.log(err, &quot;错误&quot;);  &#125;);// 简写this.$ajax.get(&quot;api/publishContent&quot;).then(  (res) =&gt; &#123;    console.log(res, &quot;请求成功&quot;);  &#125;,  (err) =&gt; &#123;    console.log(err, &quot;请求失败&quot;);  &#125;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Loading chunk {n} failed 的解决方法</title>
    <link href="undefined2020/12/01/Loading%20chunk%20%7Bn%7D%20failed/"/>
    <url>2020/12/01/Loading%20chunk%20%7Bn%7D%20failed/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h1><ul><li>前端代码更改后,每次发布到测试环境,用户的页面如果不刷新,会读取缓存,导致页面白掉!</li><li>本地没有过，都是打包到服务器上才有</li></ul><p><strong>error info</strong></p><pre><code class="js">Uncaught SyntaxError: Unexpected token &#39;&lt;&#39;Uncaught ChunkLoadError: Loading chunk 8 failed.(missing: https://mispaceuat.mihoyo.com/static/js/8.98f2a71fc60af3a81dd1.js)    at Function.i.e (https://mispaceuat.mihoyo.com/static/js/app.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:1:934)    at https://mispaceuat.mihoyo.com/static/js/app.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:1:3105    at https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1229684    at gl (https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1229833)    at sc (https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1221601)    at lc (https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1221526)    at $l (https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1218556)    at https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1170263    at e.unstable_runWithPriority (https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1244959)    at Ia (https://mispaceuat.mihoyo.com/static/js/vendor.98f2a71fc60af3a81dd1.js?98f2a71fc60af3a81dd1:2:1169972)</code></pre><h1 id="报错原因分析"><a href="#报错原因分析" class="headerlink" title="报错原因分析:"></a>报错原因分析:</h1><ul><li>webpack 打包重命名了改动过的 css 和 js 文件，并删除了原有的文件<ul><li>场景 1.用户正在浏览页面时你发包了，并且你启用了懒加载，用户的 html 文件中的 js 和 css 名称就和服务器上的不一致导致</li><li>场景 2.用户浏览器有 html 的缓存，访问了上一个版本发布的资源导致</li></ul></li><li>webpack 进行 code spilt 之后某些 bundle 文件 lazy loading 失败</li><li>其他原因：<ul><li>服务器打包时没有进行<code>rm -f public/dist/*</code>操作</li><li>chunk 文件内容是不是被篡改(通过抓包排查)</li><li>没有升级版本号导致的问题</li></ul></li></ul><h1 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h1><ul><li>刷新：会重新获取一遍 html 文档，chunk 对应信息也就刷新<ul><li>仅捕获到错误就刷新，很可能出现死循环，因为浏览器或类似于 Nginx 缓存设置的原因，浏览器不一定每次刷新去获取新的 index.html</li></ul></li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul><li><strong>方案 1</strong>：结合重试次数和重试间隔来重试，用 location.reload 方法，相当于触发 F5 刷新页面<ul><li>缺点:reload 方法，相当于触发 F5 刷新页面，用户会察觉加载刷新</li><li>捕获到了 Loading chunk {n} failed 的错误时，重新渲染目标页面，通过正则检测页面出错：用 window.location.reload(true)刷新页面</li></ul></li></ul><pre><code class="js">// prompt user to confirm refreshfunction forceRefresh() &#123;  // 设置只强制刷行一次页面  if (location.href.indexOf(&#39;#reloaded&#39;) === -1) &#123;    location.href = location.href + &#39;#reloaded&#39;;    window.location.reload(true);    // window.location.reload();  &#125; else &#123;    alert(&#39;请手动刷新页面！&#39;);  &#125;&#125;window.addEventListener(&#39;error&#39;, (e) =&gt; &#123;  const pattern = /Loading chunk (\d)+ failed/g;  const isChunkLoadFailed = error.message.match(pattern);  // const isChunkLoadFailed =  /Loading chunk [\d]+ failed/.test(e.message)  if (isChunkLoadFailed) forceRefresh();  // const targetPath = router.history.pending.fullPath;  // if (isChunkLoadFailed) router.replace(targetPath);&#125;);</code></pre><ul><li><p><strong>方案 2</strong>：构建时静态资源路径带上版本信息</p><ul><li>如路径中携带，如原来请求<code>/static/js/balabal.[hash].js</code>，现在<code>/[version]/static/balabal.[hash].js</code></li></ul></li><li><p><strong>方案 3</strong>:增加配置让页面每次加载新数据而不是走缓存,同时让后端帮忙修改 Nginx,设置 no-cache,让页面不要每次去读取缓存</p></li></ul><pre><code class="html">&lt;!-- React 入口文件添加配置让页面每次加载新数据而不是走缓存, --&gt;&lt;meta http-equiv=&quot;Cache-control&quot; content=&quot;no-cache&quot; /&gt;&lt;meta http-equiv=&quot;Cache&quot; content=&quot;no-cache&quot; /&gt;</code></pre><ul><li><strong>方案 4</strong>:尝试入口文件 client\index.tsx 处进行热更新</li></ul><pre><code class="js">declare const module: anyif (process.env.NODE_ENV === &#39;development&#39; &amp;&amp; module.hot) &#123;  module.hot.accept(&#39;./app&#39;, () =&gt; &#123;    location.reload()  &#125;)&#125;</code></pre><ul><li><p><strong>方案 5（使用 Umi 框架的项目）</strong></p><ul><li>1.<code>将 .umirc.js 中的 publicPath 配置成 / </code></li><li>2.如果构建的 dist 文件多加一层目录 base</li></ul><pre><code class="shell">location /base &#123;  # 用于配合 browserHistory使用  try_files $uri $uri/ /index.html;&#125;</code></pre></li><li><p><strong>方案 6</strong><br>找到 public&#x2F;index.html 页面,在脚本上 src 前加上”&#x2F;“</p></li></ul><pre><code class="html">&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</code></pre><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><ul><li><a href="https://zh-hans.reactjs.org/docs/error-boundaries.html">react 错误边界</a><ul><li><a href="https://segmentfault.com/a/1190000030686302">https://segmentfault.com/a/1190000030686302</a></li><li><a href="https://juejin.cn/post/6844904047313420295">https://juejin.cn/post/6844904047313420295</a></li><li><a href="https://segmentfault.com/a/1190000021575442">https://segmentfault.com/a/1190000021575442</a></li><li><a href="https://juejin.cn/post/6844903983786524680">https://juejin.cn/post/6844903983786524680</a></li><li><a href="https://stackoverflow.com/questions/59932119/react-hooks-equivalent-of-componentdidcatch">https://stackoverflow.com/questions/59932119/react-hooks-equivalent-of-componentdidcatch</a></li></ul></li><li><a href="https://github.com/x-orpheus/catch-react-error">网易开源库</a></li><li><a href="https://github.com/nuxt/nuxt.js/issues/742">GitHub 讨论</a></li></ul><h2 id="React-Lazy-的原理"><a href="#React-Lazy-的原理" class="headerlink" title="React.Lazy 的原理"></a>React.Lazy 的原理</h2><pre><code>lazyComponent is not a component but a function that returns a promise object. Inside of the promise that we return from componentLoader, we trigger the function (lazyComponent) and add handlers for promise resolve (.then) and reject(.catch). Since the successful resolution of promise is not a problem in our use case, we let React.lazy handle the resolved contents.</code></pre><pre><code class="js">function componentLoader(lazyComponent) &#123;  return new Promise((resolve, reject) =&gt; &#123;    lazyComponent()      .then(resolve)      .catch((error) =&gt; &#123;        // let us retry after 1500 ms        setTimeout(() =&gt; &#123;          // call componentLoader again!          if (attemptsLeft === 1) &#123;            reject(error);            return;          &#125;          componentLoader(lazyComponent, attemptsLeft - 1).then(            resolve,            reject          );          // add one line to make it all work        &#125;, 1500);      &#125;);  &#125;);&#125;</code></pre><p><strong>封装 retry 方法</strong></p><pre><code class="js"> function retry(  fn: () =&gt; Promise&lt;&#123;    default: React.ComponentType&lt;any&gt;;  &#125;&gt;,  retriesLeft = 100,  interval = 1000) &#123;  return new Promise&lt;&#123;    default: React.ComponentType&lt;any&gt;;  &#125;&gt;((resolve, reject) =&gt; &#123;    fn()      .then(resolve)      .catch((error: any) =&gt; &#123;        setTimeout(() =&gt; &#123;          if (retriesLeft === 1) &#123;            reject(error);            return;          &#125;          retry(fn, retriesLeft - 1, interval).then(resolve, reject);        &#125;, interval);      &#125;);  &#125;);&#125;component: lazy(() =&gt; retry(() =&gt; import(&quot;./pages/dashboard/Dashboard&quot;)))</code></pre><!-- ## 运营商的数据拦截 --><!-- // webpack动态加载原理(webpack动态加载分片的精简过后的源码)var promise = new Promise(function (resolve, reject) {  installedChunkData = installedChunks[chunkId] = [resolve, reject];});// 创建scrpit标签，再将其插入到页面上，用来在加载分片的代码var script = document.createElement("script");var onScriptComplete;script.src = jsonpScriptSrc(chunkId);onScriptComplete = function (event) {  // installedChunks[chunkId]的值变为0，代表加载成功  var chunk = installedChunks[chunkId];  // 判断 installedChunks[chunkId]是否加载成功或失败  if (chunk !== 0) {    // 如果还是一个promise则说明加载失败    // 失败的报错信息可能有两种，    // - 网络原因(服务器没有这个脚本，或执行报错)：loading chunk x failed.(error http://xxxx.xx.xx/xxx.js)    // - 数据劫持：loading chunk x failed.(missing http://xxxx.xx.xx/xxx.js)    if (chunk) {      var errorType = event && (event.type === "load" ? "missing" : event.type);      var realSrc = event && event.target && event.target.src;      var error = new Error(        "Loading chunk " +          chunkId +          " failed.\n(" +          errorType +          ": " +          realSrc +          ")"      );      error.type = errorType;      error.request = realSrc;      chunk[1](error);    }    installedChunks[chunkId] = undefined;  }};// 给script标签绑定onload/onerror事件的回调函数script.onerror = script.onload = onScriptComplete;document.head.appendChild(script);/*nstalledChunks[chunkId]的值可能有：undefined 未加载null 已经预加载promise 正在加载0 已经加载script引入的代码执行完了之后才会触发onloadwebpack动态加载分片顺序：- 标记installedChunks[chunkId] = [resolve, reject]为正在加载；- 创建script标签，从服务器加载分片；- 加载完分片代码后立即执行webpackJsonpCallback修改installedChunks[chunkId] = 0，并执行installedChunks[chunkId][0]的resolve- 执行完分片代码后，执行script的onload回调函数。判断是否加载成功，如果installedChunks[chunkId] === 0则加载成功，如果installedChunks[chunkId] === [resolve, reject]则加载失败，报错loading chunk x failed.(missing http://xxxx.xx.xx/xxx.js)*/ -->]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程之美</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我与Golang的每一天</title>
    <link href="undefined2020/05/06/Golang-Daily/"/>
    <url>2020/05/06/Golang-Daily/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-语言的优点"><a href="#Go-语言的优点" class="headerlink" title="Go 语言的优点"></a>Go 语言的优点</h1><h2 id="生产力语言"><a href="#生产力语言" class="headerlink" title="生产力语言"></a>生产力语言</h2><p>作为一门生产力语言，它有很多约束，规避代码的一些低级错误！<br>e.g..go 语言中没有前置的++和–，所以你不用担心混淆前置++和后置++的区别。</p><h2 id="可读性好，易于维护"><a href="#可读性好，易于维护" class="headerlink" title="可读性好，易于维护"></a>可读性好，易于维护</h2><p>e.g.位运算符重的<code>按位置零操作&amp;^</code></p><ul><li>右边操作数位为 1 时，结果都为 0</li><li>右边操作数位为 0 时，结果和左侧保持一直，左侧为 0，则结果为 0</li></ul><pre><code class="go">1 &amp;^ 0 -- 11 &amp;^ 1 -- 00 &amp;^ 1 -- 00 &amp;^ 0 -- 0</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渐进式迁移TypeScript</title>
    <link href="undefined2020/01/31/%E6%B8%90%E8%BF%9B%E5%BC%8F%E8%BF%81%E7%A7%BBTypeScript/"/>
    <url>2020/01/31/%E6%B8%90%E8%BF%9B%E5%BC%8F%E8%BF%81%E7%A7%BBTypeScript/</url>
    
    <content type="html"><![CDATA[<!-- 大纲（Add到个人笔记中）Demo里的README步骤 --><h1 id="使用create-react-app"><a href="#使用create-react-app" class="headerlink" title="使用create-react-app"></a>使用create-react-app</h1><p>由于老项目使用的react-app-rewired，为了更好的适配TypeScript，这里首先使用create-react-app这套构建方案替换react-app-rewired！</p><pre><code class="bash">- npm uninstall -g crete-react-app- yarn global add create-react-app- yarn create react-app my-app --template typescript- yarn add typescript- yarn add @types/react- yarn add @types/react-dom- yarn install- yarn start</code></pre><!-- yarn remove -g crete-react-app --><h2 id="渐进式迁移策略"><a href="#渐进式迁移策略" class="headerlink" title="渐进式迁移策略"></a>渐进式迁移策略</h2><h3 id="共存策略"><a href="#共存策略" class="headerlink" title="共存策略"></a>共存策略</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>原JavaScript代码不动，新增代码都用TypeScript编写</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1.添加ts(x) 文件<br>2.安装typescript<br>3.选择构建工具<br>保留Babel</p><ul><li>安装@babel&#x2F;preset-typescript</li><li>修改Webpack配置</li><li>添加tsc –watch模式</li></ul><p>放弃Babel</p><ul><li>安装ts-loader</li><li>修改Webpack配置</li></ul><p>4.检查JavaScript<br>allowJs: true<br>checkJs: true</p><p>5.处理JavaScript报错<br>&#x2F;&#x2F; @ts-nocheck<br>JSDOC注释</p><h3 id="宽松策略"><a href="#宽松策略" class="headerlink" title="宽松策略"></a>宽松策略</h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><p>将所有的js(x)文件重命名为ts(x)文件，在不修改代码的基础上，使用最宽松的类型检查规则</p><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><p>1.重命名文件(shelljs)<br>2.修改Webpack入口<br>3.strict: false</p><h3 id="严格策略"><a href="#严格策略" class="headerlink" title="严格策略"></a>严格策略</h3><h4 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h4><p>开启最严格的类型检查规则，处理剩余的报错</p><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ul><li>strict: true</li><li>处理报错</li></ul><h1 id="axios的封装-🚀"><a href="#axios的封装-🚀" class="headerlink" title="axios的封装 🚀"></a>axios的封装 🚀</h1><h2 id="安装进度条"><a href="#安装进度条" class="headerlink" title="安装进度条"></a>安装进度条</h2><p>yarn add nprogress @types&#x2F;nprogress</p><ul><li><strong>request.ts</strong></li><li><strong>http.js</strong><!-- 将GTA作为Ts的Demo模版，对比和公司axios请求封装的区别对比长包、销售、考拉几个项目的 axios 封装方式写法一：销售系统那种写法二：考拉爱车官网项目中 utils/request.js 代码 --></li></ul><p><a href="https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide">JS项目–TS项目迁移官方例子</a></p><!-- src/components/GlobalHeader/index.less注释掉一些:global```diff- :global {.ant-layout {  min-height: 100vh;  overflow-x: hidden;  // width:165px;  //   max-width:165px;  //   min-width:165px;}- }``` --><!-- 正文，通过笔记拓展----------```ts``` -->]]></content>
    
    
    <categories>
      
      <category>快乐编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参加第14届D2前端技术大会后的感悟</title>
    <link href="undefined2019/12/16/%E7%AC%AC14%E5%B1%8AD2%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9A/"/>
    <url>2019/12/16/%E7%AC%AC14%E5%B1%8AD2%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<p>继 19 年 VueConf 之后，这是我第二次参加技术大会！虽然大部分内容听不懂，但还是有不小收获，也给 2020 年的学习方向起到了一些引导作用！尤其是在晚会 D2 之夜上听大佬们的学习历程，不禁让我陷入了沉思！这天晚上我脑子里时时刻刻回想着《霸王别姬》里面的一个镜头！</p><!-- “xxx对xxx说”：是要挨多少打，才能成为角啊！ add霸王镜头--><p>我相信前端学习，肉体上不用挨打，但心灵上肯定是饱受历练的，希望有一天我也能像几位大佬一样在编码前沿跟后生谈笑风生！</p><!-- > 白天是热门或新技术的专场 --><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><!-- 体现自己在思考问题 --><ul><li><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MjE5OTI4Mw==&mid=2247484246&idx=1&sn=fb3fabb3e7b6b3169289fe709de9c0fd&chksm=cf5b1ccaf82c95dcb692e2ed4c246944f73057573b29f1be2b7cd8caa720f6dc9254871a5980&token=1631420129&lang=zh_CN#rd">标准微前端架构在蚂蚁的落地实践</a></li><li><a href="http://pc-shop.xiaoe-tech.com/app8t0DSHwT1047/imgtext_details?id=i_5dee26d30c780_wfpkqKTc">第十四届 D2 大会资料</a></li><li><a href="https://github.com/d2forum/14th">第十四届 D2 大会 PPT</a></li><li><a href="https://www.yuque.com/d2forum/content/egk1pc">第 14 届 D2 完整资料</a></li></ul><h1 id="值得了解的技术"><a href="#值得了解的技术" class="headerlink" title="值得了解的技术"></a>值得了解的技术</h1><ul><li>Node 的 Serverless</li><li>微前端（Micro Frontends Web），推广到业务项目中，提高开发效率、优化团队协作成本</li><li><a href="https://github.com/css-modules/css-modules/blob/master/docs/composition.md">CSS Modules</a>：简单高效、尤其体现在处理子应用样式隔离。<!-- 字节跳动和阿里 --></li></ul><h1 id="开源仓库-x2F-学习资源"><a href="#开源仓库-x2F-学习资源" class="headerlink" title="开源仓库&#x2F;学习资源"></a>开源仓库&#x2F;学习资源</h1><ul><li>umi 插件</li><li>微前端内核</li><li>Umiqs&#x2F;qiankun<!-- （GitHub Search from PPT） --></li><li><a href="https://github.com/css-modules/css-modules/blob/master/docs/composition.md">CSS Modules</a></li></ul><h1 id="值得关注的一些平台"><a href="#值得关注的一些平台" class="headerlink" title="值得关注的一些平台"></a>值得关注的一些平台</h1><ul><li><a href="https://github.com/tc39">制定 JS 规范的组织的 TC39</a></li></ul><!-- # 回顾 PPT --><!-- 生态云新物种 --><!-- 微前端沙盒体系 （艾石光/字节跳动 ‘微前端专场’） --><h1 id="D2-晚会"><a href="#D2-晚会" class="headerlink" title="D2 晚会"></a><a href="https://www.yuque.com/zhaishenking/ggn07n/uvdo44">D2 晚会</a></h1><h1 id="2020-年的自我计划（学习质量-gt-学习数量）"><a href="#2020-年的自我计划（学习质量-gt-学习数量）" class="headerlink" title="2020 年的自我计划（学习质量&gt;学习数量）"></a>2020 年的自我计划（学习质量&gt;学习数量）</h1><ul><li>算法：通过 LeetCode 保持算法思维</li><li>Golang</li><li>Flutter</li><li>性能优化</li><li>音视频方向</li><li>源码阅读计划（避免成为 API 工程师）<ul><li>对比不同 UI 库与 antd 实现的区别，思考它们的设计思路</li><li>针对自己感兴趣的组件去看看源码了解其实现原理<!-- 思考开发过程中浪费时间的流程，并想办法解决它 --></li></ul></li></ul><h1 id="思维能力的培养"><a href="#思维能力的培养" class="headerlink" title="思维能力的培养"></a>思维能力的培养</h1><p>从 bug 追根溯源</p><ul><li>解决问题之后思考更好的解决方案</li><li>什么原因导致这类 bug</li><li>不满足于 API 的使用</li><li>去了解 API 底层原理，挑自己喜欢的组件去看实现原理</li><li>不只看结果，深究重塑</li><li>多思考如果让我实现，我该怎么写-&gt;写 Demo-&gt;看源码-&gt;思考有无更优解</li><li>自己写完的东西-&gt;看看别人的解法-&gt;思考有无更优解</li><li>多角度思考问题</li><li>思考产品、老板、运营、后端是怎么想（多去交流沟通）</li><li>多读书</li><li>读一些技术无关的书籍，学更多的东西，思考技术方案如何落地到项目！<ul><li>人物传记，看伟人如何思考问题</li><li>认知提升类书籍</li></ul></li></ul><h1 id="前端的自我修养"><a href="#前端的自我修养" class="headerlink" title="前端的自我修养"></a>前端的自我修养</h1><p><strong>虽然我的职业规划不止步于前端，但我很认同大佬们说的前端该具备的几点自我修养！</strong></p><ul><li>做任何需求心态要好，不要急，但要保证效率</li><li>像素眼-&gt;高度还原 UI 高保真图</li><li>EQ 要高，善于沟通</li><li>最终必须变为全栈（强烈赞同）</li><li>有浓厚的好奇心</li><li>前端开发工程师的终极目标应该是：开发+运维</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术大会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不想做API工程师</title>
    <link href="undefined2019/12/12/%E4%B8%8D%E6%83%B3%E5%81%9AAPI%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <url>2019/12/12/%E4%B8%8D%E6%83%B3%E5%81%9AAPI%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<p>曾有人跟我说说：‘高手与低手的区别在于读库能力与调试能力。’我觉得很在理，所以也制定一些源码阅读计划！</p><ul><li><a href="https://github.com/RubyLouvre/anu">迷你React框架anujs源码</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>源码阅读</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ant-Design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React性能优化</title>
    <link href="undefined2019/12/10/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>2019/12/10/React%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="项目中的代码分割"><a href="#项目中的代码分割" class="headerlink" title="项目中的代码分割"></a>项目中的代码分割</h1><p>import 静态引入写法</p><pre><code class="jsx">import Home from &quot;./components/Home&quot;;import Login from &quot;./components/Login&quot;;...return(  &lt;Router&gt;    &lt;Switch&gt;      &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt;      &lt;Route path=&quot;/login&quot; component=&#123;Login&#125; /&gt;      &lt;Route path=&quot;/posts&quot; component=&#123;Home&#125; /&gt;  ...)</code></pre><p>以上写法不管匹配到了哪一个 route，都是一次性地引入所有的组件。可以使用代码分割进行优化，实现只引入匹配到的 route 和对应组件。</p><h2 id="创建一个异步组件-asyncComponent-替换-import-动态导入的-Login-和-Home-组件，实现按需异步加载"><a href="#创建一个异步组件-asyncComponent-替换-import-动态导入的-Login-和-Home-组件，实现按需异步加载" class="headerlink" title="创建一个异步组件 asyncComponent 替换 import 动态导入的 Login 和 Home 组件，实现按需异步加载"></a>创建一个异步组件 asyncComponent 替换 import 动态导入的 Login 和 Home 组件，实现按需异步加载</h2><p><strong>utils&#x2F;AsyncComponent&#x2F;asyncComponent.jsx</strong></p><pre><code class="jsx">import React, &#123; Component &#125; from &quot;react&quot;;export default function asyncComponent(importComponent) &#123;  // asyncComponent 接收一个 importComponent函数作为参数，importComponent()在被调用时会动态引入给定的组件。  class AsyncComponent extends Component &#123;    constructor(props) &#123;      super(props);      this.state = &#123;        component: null      &#125;;    &#125;    componentDidMount() &#123;      // 调用传入的importComponent()，并将动态引入的组件保存在state中      importComponent().then(mod =&gt; &#123;        // import()方法返回的是一个Promise，Promise的返回值只能通过then()来读取        this.setState(&#123;          // 同时兼容ES6和CommonJS的模块          component: mod.default ? mod.default : mod        &#125;);      &#125;);    &#125;    render() &#123;      const C = this.state.component;      return C ? &lt;C &#123;...this.props&#125; /&gt; : null;    &#125;  &#125;  return AsyncComponent;&#125;</code></pre><h3 id="使用-asyncComponent-组件"><a href="#使用-asyncComponent-组件" class="headerlink" title="使用 asyncComponent 组件"></a>使用 asyncComponent 组件</h3><p><strong>src&#x2F;components&#x2F;App&#x2F;index.js</strong></p><pre><code class="jsx">import asyncComponent from &quot;../../utils/AsyncComponent&quot;;// 使用asyncComponent组件来创建代码分片点替换import动态导入的Login和Home组件const AsyncHome = connectRoute(asyncComponent(() =&gt; import(&quot;../Home&quot;)));const AsyncLogin = connectRoute(asyncComponent(() =&gt; import(&quot;../Login&quot;)));//传给 asyncComponent 一个函数，在 AsyncHome 组件被创建时对组件进行动态引入 这里并没有进行组件的引入...  return(    &lt;div&gt;      &lt;Router&gt;        &lt;Switch&gt;          &#123;/* 使用这个 AsyncHome 组件*/&#125;          &lt;Route exact path=&quot;/&quot; component=&#123;AsyncHome&#125; /&gt;          &lt;Route path=&quot;/login&quot; component=&#123;AsyncLogin&#125; /&gt;          &lt;Route path=&quot;/posts&quot; component=&#123;AsyncHome&#125; /&gt;    ...  )...</code></pre><h1 id="不要把所有的数据都往-State-中塞"><a href="#不要把所有的数据都往-State-中塞" class="headerlink" title="不要把所有的数据都往 State 中塞"></a>不要把所有的数据都往 State 中塞</h1><p>如后端数据，且数据为不需要在页面变动</p><pre><code class="json">  &quot;data&quot;: &#123;    &quot;result&quot;: &#123;      &quot;id&quot;: 2,      &quot;totalUserCount&quot;: 634801,      &quot;totalSilentUserCount&quot;: 631192,      &quot;totalAccountCount&quot;: 29012,      &quot;creationTime&quot;: &quot;2019-12-12T14:46:45.423&quot;    &#125;,    &quot;isSuccess&quot;: true,    &quot;errorCode&quot;: 0,    &quot;message&quot;: &quot;&quot;  &#125;,</code></pre><p>那么我们只需要把 result 放入 state 即可</p><pre><code class="jsx">this.setState(&#123;  Data:result&#125;)const &#123;Data&#125;  = this.state....&lt;span style=&#123;&#123; color: '#333333', fontSize: '14px' &#125;&#125;&gt;  &lt;a href=&quot;#&quot;&gt;    &#123;Data.totalUserCount&#125;  &lt;/a&gt;  个，</code></pre>]]></content>
    
    
    <categories>
      
      <category>快乐编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React 那些事儿</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>效率至上的Mobx</title>
    <link href="undefined2019/12/09/%E6%95%88%E7%8E%87%E8%87%B3%E4%B8%8A%E7%9A%84Mobx/"/>
    <url>2019/12/09/%E6%95%88%E7%8E%87%E8%87%B3%E4%B8%8A%E7%9A%84Mobx/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么会考虑使用状态管理？"><a href="#为什么会考虑使用状态管理？" class="headerlink" title="为什么会考虑使用状态管理？"></a>为什么会考虑使用状态管理？</h1><p>项目开发中经常会碰到以下场景：<br>1.业务系统许多接口，入参都需要传递登陆人 id</p><pre><code class="jsx">userCode: localStorage.getItem(&#39;userCode&#39;),</code></pre><p>2.业务系统选择下拉框，如城市，销售业务员、车型、折旧选项等均为同一接口数据。</p><pre><code class="jsx">// 获取司机信息getDrivers(name) &#123;  http    .get(&quot;/api/Common/GetDrivers&quot;, &#123;      Key: name    &#125;)    .then(res =&gt; &#123;      const &#123; success, result &#125; = res.data;      if (success) &#123;        if (Array.isArray(result)) &#123;          this.setState(&#123;            drivers: result          &#125;);        &#125; else &#123;          this.setState(&#123;            drivers: []          &#125;);        &#125;      &#125; else &#123;        message.error(&quot;获取司机信息失败&quot;);      &#125;    &#125;)    .catch(err =&gt; &#123;      console.error(err);    &#125;);&#125;</code></pre><p>3.兄弟组件传值等</p><!-- [1]台词 --><h1 id="MobX-背后的哲学"><a href="#MobX-背后的哲学" class="headerlink" title="MobX 背后的哲学"></a>MobX 背后的哲学</h1><p>任何可以从应用程序的状态中获取&#x2F;衍生的数据都应该可以自动被获取&#x2F;衍生。<br>MobX 遵循单项数据流，通过 action 改变 state(可观测对象)，state 的变化又会触发 computed value 和 reaction 的重新执行。</p><!-- [2]台词 --><h1 id="Redux-和-Mobx-相同点"><a href="#Redux-和-Mobx-相同点" class="headerlink" title="Redux 和 Mobx 相同点"></a>Redux 和 Mobx 相同点</h1><p>1.优秀的状态管理解决方案<br>2.采用单向数据流管理状态<br>3.<code>Action--&gt;State--&gt;Views</code></p><h1 id="Mobx-和-Redux-的区别"><a href="#Mobx-和-Redux-的区别" class="headerlink" title="Mobx 和 Redux 的区别"></a>Mobx 和 Redux 的区别</h1><table><thead><tr><th>Mobx</th><th>Redux</th></tr></thead><tbody><tr><td>多个 store 对象，多 store 间的数据共享、相互引用</td><td>单一数据源，应用共享一个 store 对象</td></tr><tr><td>state 结构可以任意嵌套</td><td>state 结构尽可能的扁平化，从而减少嵌套层级</td></tr><tr><td>state 可观测，可以直接修改</td><td>普通 JavaScript 对象存储 state</td></tr><tr><td>上手成本低、开发效率高</td><td>需要熟悉函数式编程基础</td></tr><tr><td>代码量更少</td><td>需要写更多的代码来执行严格的规范</td></tr></tbody></table><!-- [3]台词 --><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><table><thead><tr><th>MobX</th><th>Redux</th></tr></thead><tbody><tr><td>相对简单的应用</td><td>复杂度较高的应用</td></tr></tbody></table><!-- [4]台词 --><h1 id="MobX-包含的主要概念"><a href="#MobX-包含的主要概念" class="headerlink" title="MobX 包含的主要概念"></a>MobX 包含的主要概念</h1><ul><li>state（状态）</li><li>computed value（计算值）</li><li>reaction（响应）<ul><li>computed value 和 reaction 会自动根据 state 的改变做最小化的更新</li></ul></li><li>action（动作）<!-- [5]台词 --></li></ul><h1 id="Mobx-的缺点"><a href="#Mobx-的缺点" class="headerlink" title="Mobx 的缺点"></a>Mobx 的缺点</h1><p>如使用装饰器时团队如果不制定一个规范，后期可能难以维护。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>自定义装饰器还是要在项目组内达成共识才行。<br>如：将各个状态封装到一个对象中导出（防止代码难以维护，加入静态图和 gif 图）<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/%E7%BB%9F%E4%B8%80%E5%AF%B9%E8%B1%A1-20191210.png" alt="统一对象"></p><p>将使用 Mobx 观测的数据整合到一个 stores 对象注入到 Provider<br>到‘src&#x2F;stores&#x2F;index.js’中</p><h1 id="获取可观测的-state"><a href="#获取可观测的-state" class="headerlink" title="获取可观测的 state"></a>获取可观测的 state</h1><p>通过 React-mobx 提供 Provider 组件在根目录 index.jsx 中让容器组件拿到 state</p><pre><code class="jsx">import &#123; Provider &#125; from &quot;mobx-react&quot;;import stores from &quot;./stores&quot;;...&lt;Provider &#123;...stores&#125;&gt;  &lt;App /&gt;&lt;/Provider&gt;,document.getElementById(&#39;root&#39;)</code></pre><p>Provider 在根组件外包了一层，来让 App 的所有子组件就默认都可以拿到 state。<br><a href="https://github.com/mobxjs/mobx-react/raw/master/src/Provider.js">Provider 源码</a><br>只有先获取到 state，在对应组件中才能使用 inject 注入</p><h2 id="inject-注入使用的-Store"><a href="#inject-注入使用的-Store" class="headerlink" title="@inject 注入使用的 Store"></a>@inject 注入使用的 Store</h2><pre><code class="jsx">import &#123; observer, inject &#125; from &quot;mobx-react&quot;;import &#123; observable &#125; from &quot;mobx&quot;;@observer@inject(&quot;store&quot;) // inject从context中取出store对象，注入到组件的props中class App extends Component &#123;  render() &#123;    const &#123; store &#125; = this.props;    return (      &lt;div&gt;        &lt;ul&gt;          &#123;store.map(todo =&gt; (            &lt;TodoView todo=&#123;todo&#125; key=&#123;todo.id&#125; /&gt;          ))&#125;        &lt;/ul&gt;      &lt;/div&gt;    );  &#125;&#125;const TodoView = observer((&#123; todo &#125;) =&gt; &#123;  return &lt;li&gt;&#123;todo.title&#125;&lt;/li&gt;;&#125;);</code></pre><!-- [6]台词 --><h1 id="配置装饰器语法"><a href="#配置装饰器语法" class="headerlink" title="配置装饰器语法"></a>配置装饰器语法</h1><p><strong>项目中会大量使用到装饰器语法@observable，所以要提前配置装饰器</strong><br><a href="https://mobx.js.org/best/decorators.html">配置方案</a><br><a href="https://github.com/EdisonVan/MobxDemo/blob/master/jsconfig.json">记得配置jsconfig</a></p><!-- [7]台词 --><h2 id="computed-value-的使用"><a href="#computed-value-的使用" class="headerlink" title="computed value 的使用"></a>computed value 的使用</h2><p><img src="https://github.com/EdisonVan/GraphBed/raw/master/Loading%E7%8A%B6%E6%80%81%E5%AE%9E%E7%8E%B0-20191210.png" alt="Loading-20191210"><br><img src="https://github.com/EdisonVan/GraphBed/raw/master/Loading-20191210.gif" alt="Loading状态 gif"></p><!-- [8]台词 --><p>一般通过<code>computed</code>和<code>@computed</code>创建<code>computed value</code></p><pre><code class="js">computed(() =&gt; expression)@computed get classProperty() &#123; return expression; &#125;</code></pre><!-- [9]台词 --><h2 id="action-的使用"><a href="#action-的使用" class="headerlink" title="action 的使用"></a>action 的使用</h2><h3 id="常见的用法"><a href="#常见的用法" class="headerlink" title="常见的用法"></a>常见的用法</h3><pre><code class="js">action(fn)@action classMethod</code></pre><p><img src="https://github.com/EdisonVan/GraphBed/raw/master/action%E7%9A%84%E4%BD%BF%E7%94%A8-20191210.png" alt="action的使用.png"></p><!-- [10]台词 --><h3 id="action-bound解决this指向问题"><a href="#action-bound解决this指向问题" class="headerlink" title="action.bound解决this指向问题"></a>action.bound解决this指向问题</h3><p><strong>箭头函数</strong></p><pre><code class="jsx">logout = () =&gt;&#123;    this.userId = undefined;    this.username = &#39;jack&#39;;    this.password = &#39;123456&#39;;    sessionStorage.removeItem(&quot;userId&quot;);    sessionStorage.removeItem(&quot;username&quot;);&#125;</code></pre><p><strong>action.bound&#x2F;@action.bound</strong></p><pre><code class="jsx">  @action.bound logout() &#123;    this.userId = undefined;    this.username = &#39;jack&#39;;    this.password = &#39;123456&#39;;    sessionStorage.removeItem(&quot;userId&quot;);    sessionStorage.removeItem(&quot;username&quot;);  &#125;</code></pre><pre><code class="jsx">&#123;  authStore.userId &amp;&amp; authStore.userId.length &gt; 0 ? (    &lt;span className=&quot;user&quot;&gt;      当前用户：&#123;authStore.username&#125;&amp;nbsp;      &lt;button onClick=&#123;authStore.logout&#125;&gt;注销&lt;/button&gt;    &lt;/span&gt;  ) : (    &lt;span className=&quot;right-link&quot;&gt;      &lt;Link to=&#123;&#123; pathname: "/login", state: &#123; from: location &#125; &#125;&#125;&gt;登录&lt;/Link&gt;    &lt;/span&gt;  );&#125;</code></pre><!-- [11]台词 --><h1 id="mobx-调试工具"><a href="#mobx-调试工具" class="headerlink" title="mobx 调试工具"></a>mobx 调试工具</h1><p>mobx-react-devtools 是一个用于调试 MobX+React 项目的工具，可以追踪组件的渲染以及组件依赖的可观测数据。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>只需要在开发环境下使用调试工具，安装命令使用的参数是–save-dev</strong></p><pre><code>npm install mobx-react-devtools --save-dev或yarn add mobx-react-devtools --save-dev</code></pre><p>再次运行程序，界面右上角会多出三个小图标，是 mobx-react-devtools 的功能键。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>点击第一个图标，当组件发生渲染行为时，对应的组件会被高亮显示<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/DevTool-Button1-20191210.gif" alt="DevTool-Button1.gif"></p><ul><li>高亮组件右上角显示的 3 个数字分别代表截至当前组件渲染的次数、组件 render 方法执行的时间、组件从 render 方法开始到渲染到浏览器界面使用的时间<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/Button1%E6%B3%A8%E9%87%8A.png" alt="Button1注释.png"></li></ul><p>点击第二个图标后，再用鼠标选择任意一个组件，可以查看该组件会对哪些数据的变化做出响应<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/DevTool-Button2-20191210.gif" alt="DevTool-Button2.gif"></p><p>点击第三个图标，控制台会输出发生的 action、响应的 reaction 等调试日志信息<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/DevTool-Button3-20191210.gif" alt="DevTool-Button3.gif"></p><p>当然你也可以<a href="https://cn.mobx.js.org/best/trace.html">使用 trace 进行调试</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://mobx.js.org/README.html">Mobx 官方文档</a></li><li><a href="https://developers.youzanyun.com/article/1557135472680?p=1&m=0">我为什么从 Redux 迁移到了 Mobx</a></li><li>《React 进阶之路》–徐超</li></ul><h1 id="入门项目推荐"><a href="#入门项目推荐" class="headerlink" title="入门项目推荐"></a>入门项目推荐</h1><p><a href="https://github.com/EdisonVan/MobxDemo">《React进阶之路》bbs项目案例</a></p><!-- [12]台词（总结） -->]]></content>
    
    
    <categories>
      
      <category>快乐编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React 那些事儿</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code Review-磨刀不费砍柴功！</title>
    <link href="undefined2019/10/31/Code%20Review-%E7%A3%A8%E5%88%80%E4%B8%8D%E8%B4%B9%E7%A0%8D%E6%9F%B4%E5%8A%9F%EF%BC%81/"/>
    <url>2019/10/31/Code%20Review-%E7%A3%A8%E5%88%80%E4%B8%8D%E8%B4%B9%E7%A0%8D%E6%9F%B4%E5%8A%9F%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p><strong><code>Code Review</code>和写自动化测试一样，都是磨刀不误砍柴工的工作!</strong></p><h1 id="Commit-规范"><a href="#Commit-规范" class="headerlink" title="Commit 规范"></a>Commit 规范</h1><p>整理 CodeReview 规范、commit 内容</p><ul><li><p>commit 规范分享</p></li><li><p>Dev-Tool&#x2F;Front-end-Tool&#x2F;踩坑 Gti&#x2F;Content&#x2F;SubmitSpecification.md<br><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODY2NjA1Nw==&mid=2247483912&idx=1&sn=b8dff8e68806982cb21ff7ea8ad1c031&chksm=eb52cc2edc254538fee09f38d5ce2b553ed782f79d2d80357b3c50a666cb413817c729d07d74&scene=21#wechat_redirect">如何做好 Python 代码的 Code Review–章老师说</a></p></li></ul><p>✔ 每次代码提交应该都要确保是一个最小的完整功能<br>✔ 每个 <code>Commit</code> 只应该干一件事<br>✔ 每次提交后的代码库应该都是正常运行<br>✔ 每次提交应该按照下面的规范添加操作类型<br>✔ 每次 <code>Commit</code> 都要明确具体操作类型</p><blockquote><p>✨ Feat: 车辆管理（查看车辆信息） #650070<br>🐛 Fix: 电子合同，驳回原因应有必填校验 #640609</p></blockquote><table><thead><tr><th align="center">操作类型</th><th align="center">前缀</th><th align="center">Emoji 符号（可选）</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">添加功能</td><td align="center">Feature 或 Feat</td><td align="center">✨</td><td align="center">后面要跟着对应功能的 <code>iWork</code> 编号</td></tr><tr><td align="center">优化代码（代码结构）</td><td align="center">Style</td><td align="center">🎨</td><td align="center">不影响代码功能，特指代码结构优化</td></tr><tr><td align="center">重构</td><td align="center">Refactor</td><td align="center">🔨</td><td align="center">大范围级别项目重构</td></tr><tr><td align="center">添加测试</td><td align="center">Test</td><td align="center">✅</td><td align="center">添加单元测试</td></tr><tr><td align="center">性能优化</td><td align="center">Performance</td><td align="center">⚡</td><td align="center">提升性能有关的优化</td></tr><tr><td align="center">合并代码</td><td align="center">Merge</td><td align="center">🔀</td><td align="center">跟别人冲突了之后执行合并时</td></tr><tr><td align="center">临时的脏代码</td><td align="center">Shit</td><td align="center">💩</td><td align="center">屎一样的代码，未来需要优化的临时脏代码</td></tr><tr><td align="center">包更新</td><td align="center">Upgrade</td><td align="center">⬆️</td><td align="center">升级 npm 包</td></tr><tr><td align="center">包降级</td><td align="center">Downgrade</td><td align="center">⬇️</td><td align="center">降级 npm 包</td></tr><tr><td align="center">修复 Bug</td><td align="center">Fix</td><td align="center">🐛</td><td align="center">修复 Bug 的提交</td></tr><tr><td align="center">填写注释</td><td align="center">Document 或 Doc</td><td align="center">💡</td><td align="center">为代码编写注释</td></tr><tr><td align="center">破坏性改动</td><td align="center">Breaking Change</td><td align="center">💥</td><td align="center">所提供的接口或者方法出现重大不兼容更改</td></tr><tr><td align="center">配置修改</td><td align="center">Config</td><td align="center">🔧</td><td align="center">配置修改（如 <code>webpack</code> 中 <code>process.ENV</code>）</td></tr><tr><td align="center">配合代码审查的更改</td><td align="center">Code Review</td><td align="center">👌</td><td align="center">配合代码审查提出的改进意见做的提交</td></tr><tr><td align="center">开发进行中</td><td align="center">Doing&#x2F;InProgress</td><td align="center">🚧</td><td align="center">一个大功能开发过程中，必须需要跟着对应功能的 <code>iWork</code> 编号</td></tr><tr><td align="center">代码移动或者重命名</td><td align="center">Rename&#x2F;Move</td><td align="center">🚚</td><td align="center"></td></tr><tr><td align="center">代码删除</td><td align="center">Remove&#x2F;Delete</td><td align="center">🔥</td><td align="center"></td></tr></tbody></table><h1 id="前端：推荐用-VsCode-插件Visual-Studio-Code-Commitizen-Support来设置提交规范"><a href="#前端：推荐用-VsCode-插件Visual-Studio-Code-Commitizen-Support来设置提交规范" class="headerlink" title="前端：推荐用 VsCode 插件Visual Studio Code Commitizen Support来设置提交规范"></a>前端：推荐用 VsCode 插件<a href="https://github.com/KnisterPeter/vscode-commitizen">Visual Studio Code Commitizen Support</a>来设置提交规范</h1><p>使用教程：</p><ul><li>Step1.快捷键<code>command+shift+p</code>打开命令面板输入 conventional commit</li><li>Step2.选择提交类型</li><li>Step3.填写 commit 信息、iWork 编号（选），回车完成 push 操作</li></ul><h1 id="Code-Review-的好处"><a href="#Code-Review-的好处" class="headerlink" title="Code Review 的好处"></a>Code Review 的好处</h1><ul><li>让高水平的帮助新人成长，指出新手代码中的问题</li><li>形成代码规范，保证有人离职后其他人能快速接手</li></ul><h1 id="如何审核"><a href="#如何审核" class="headerlink" title="如何审核"></a>如何审核</h1><h2 id="将代码的审查设置为开发流程的必选项"><a href="#将代码的审查设置为开发流程的必选项" class="headerlink" title="将代码的审查设置为开发流程的必选项"></a>将代码的审查设置为开发流程的必选项</h2><p>每次开发新功能或修复 Bug，开一个新的分支，分支要合并到 master 必须满足以下条件</p><ul><li>所有的自动化测试通过</li><li>至少有一个人 Code Review 通过<ul><li>如果是新手的 PR，还必须有资深程序员 Code Review 通过</li></ul></li><li>保证每次审查的代码量也不会太大，减轻审查者压力<ul><li>提交 PR 时，保证 PR 要小，相对就比较容易 Review，也容易发现代码中可能存在的问题</li><li>针对比较大的改动，最好分批提交，以减轻审查者的压力</li></ul></li><li>Code Review 时发现问题，被审查者要积极的对审查出来的问题进行修改</li></ul><h2 id="把-Code-Review-变成一种开发文化而不仅仅是一种制度"><a href="#把-Code-Review-变成一种开发文化而不仅仅是一种制度" class="headerlink" title="把 Code Review 变成一种开发文化而不仅仅是一种制度"></a>把 Code Review 变成一种开发文化而不仅仅是一种制度</h2><ul><li>有几个人做好表率作用，榜样的力量很重要</li><li>对于管理者来说，你激励什么，往往就会得到什么</li><li>像写自动化测试一样，把 Code Review 作为开发任务的一部分，给审查者和被审查者都留出专门的时间去做这件事</li></ul><h1 id="Code-Review-的经验技巧"><a href="#Code-Review-的经验技巧" class="headerlink" title="Code Review 的经验技巧"></a>Code Review 的经验技巧</h1><h2 id="先设计再编码"><a href="#先设计再编码" class="headerlink" title="先设计再编码"></a>先设计再编码</h2><ul><li>在做一个新功能之前，写一个简单的设计文档，表达清楚自己的设计思路！</li><li>找资深的开发先帮忙做一下设计的审查，发现设计上的问题！</li><li>设计上没问题了，再着手开发！</li></ul><h2 id="利用辅助工具"><a href="#利用辅助工具" class="headerlink" title="利用辅助工具"></a>利用辅助工具</h2><ul><li>本地搭建环境根据自己的需要配置 Gitlab</li></ul><h2 id="遇到紧急情况，来不及代码审查怎么办？"><a href="#遇到紧急情况，来不及代码审查怎么办？" class="headerlink" title="遇到紧急情况，来不及代码审查怎么办？"></a>遇到紧急情况，来不及代码审查怎么办？</h2><p><strong>比如，线上故障补丁，而又没有其他人在线的场景</strong><br>在任务管理系统中，创建一个 Ticket，用来后续跟踪，确保后续补上 Code Review，并对 Code Review 结果有后续的代码更新</p><h2 id="代码在提交-CODE-REVIEW-之前，作者要自己先-REVIEW-和测试一遍"><a href="#代码在提交-CODE-REVIEW-之前，作者要自己先-REVIEW-和测试一遍" class="headerlink" title="代码在提交 CODE REVIEW 之前，作者要自己先 REVIEW 和测试一遍"></a>代码在提交 CODE REVIEW 之前，作者要自己先 REVIEW 和测试一遍</h2><ul><li>好的开发人员，代码在提交 Code Review 之前，肯定是要自己先 Review 一遍，把该写的自动化测试代码写上，自己把基本的测试用例跑一遍</li><li><strong>要求团队提交的 PR 在 PR 的描述中增加截图或者录屏，通过截图或者录屏，确保提交 PR 的人自己是先测试过</strong></li></ul><h3 id="windows-系统推荐"><a href="#windows-系统推荐" class="headerlink" title="windows 系统推荐"></a>windows 系统推荐</h3><p><a href="https://www.screentogif.com/">ScreenToGif</a></p><h3 id="mac-系统推荐"><a href="#mac-系统推荐" class="headerlink" title="mac 系统推荐"></a>mac 系统推荐</h3><p><a href="https://www.cockos.com/licecap/">LICEcap</a></p><h2 id="对评论进行分级"><a href="#对评论进行分级" class="headerlink" title="对评论进行分级"></a>对评论进行分级</h2><p>以对 Review 的评论进行分级，不同级别的结果可以打上不同的 Tag</p><ul><li><code>[blocker]</code>: 在评论前面加上一个[blocker]标记，表示这个代码行的问题必须要修改</li><li><code>[optional]</code>：在评论前面加上一个[optional]标记，表示这个代码行的问题可改可不改</li><li><code>[question]</code>：在评论前面加上一个[question]标记，表示对这个代码行不理解，有问题需要问，被审查者需要针对问题进行回复澄清<blockquote><p>评论要友好，避免负面词汇；有说不清楚的问题当面沟通，面对面的沟通效率更高，也容易消除误解。</p></blockquote></li></ul><blockquote><p>实践方案（GitLab&#x2F;GitHub）：<code>Settings-&gt;Branches</code>设置保护分支</p></blockquote><p>参考：<br><a href="https://mp.weixin.qq.com/s/JinlEjmWPJ3Ua6DrW74ABg">不容错过，前端 Code Review 的最佳实践方案来了</a></p><h1 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h1><ul><li>一堆人拉一个会议室 Review 代码（浪费时间）</li><li>发 Pr 到群里，让大家抽时间看，然后提 issue 即可</li></ul>]]></content>
    
    
    <categories>
      
      <category>快乐编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程之美</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tree Component Data Processing</title>
    <link href="undefined2019/10/24/TreeComponentAlgorithm/"/>
    <url>2019/10/24/TreeComponentAlgorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="https://github.com/EdisonVan/GraphBed/raw/master/AntTree-20191024.gif" alt="AntTree-20191024.gif"></p><h2 id="后端接口返回数据OriginResult"><a href="#后端接口返回数据OriginResult" class="headerlink" title="后端接口返回数据OriginResult"></a>后端接口返回数据<code>OriginResult</code></h2><pre><code>&quot;result&quot;: [  &#123;    &quot;province&quot;: &#123;      &quot;name&quot;: &quot;安徽&quot;,      “id”:&#39;0-0&#39;    &#125;,    &quot;city&quot;: [      &#123;        &quot;name&quot;: &quot;安庆&quot;,        parentId:&#39;0-0&#39;      &#125;,      &#123;        &quot;name&quot;: &quot;蚌埠&quot;      &#125;,    ]  &#125;,  &#123;    &quot;province&quot;: &#123;      &quot;name&quot;: &quot;重庆&quot;    &#125;,    &quot;city&quot;: [      &#123;        &quot;name&quot;: &quot;重庆&quot;      &#125;    ]  &#125;]</code></pre><h2 id="Ant-的-Tree-组件需要的数据格式如下"><a href="#Ant-的-Tree-组件需要的数据格式如下" class="headerlink" title="Ant 的 Tree 组件需要的数据格式如下"></a>Ant 的 Tree 组件需要的数据格式如下</h2><pre><code>treeData: [  &#123;    &quot;title&quot;: &#39;安徽&#39;,    &quot;key&quot;: 0,    &quot;children&quot;: [      &#123;        &quot;title&quot;: &#39;安庆&#39;,        &quot;key&quot;: &quot;0-0&quot;      &#125;,      &#123;        &quot;title&quot;: &#39;蚌埠&#39;,        &quot;key&quot;: &quot;0-1&quot;      &#125;    ],  &#125;,  &#123;    &quot;title&quot;: &#39;重庆&#39;,    &quot;key&quot;: &quot;重庆&quot;  &#125;,];</code></pre><h1 id="后端数据转换为-Tree-组件所需数据的算法"><a href="#后端数据转换为-Tree-组件所需数据的算法" class="headerlink" title="后端数据转换为 Tree 组件所需数据的算法"></a>后端数据转换为 Tree 组件所需数据的算法</h1><pre><code>let navs = [];if (OriginResult != undefined &amp;&amp; OriginResult.length &gt; 0) &#123;  // 先确认后端返回数据不为空  OriginResult.forEach((item, index) =&gt; &#123;    // 第一次遍历给省份数据加入key    let i = &#123;&#125;;    let PIndex = index++; // PIndex用于作最外层的key    if (item[&quot;city&quot;].length &gt; 1) &#123;      // 不是直辖市对应city就有多个      i[&quot;title&quot;] = item.province.name;      i[&quot;key&quot;] = PIndex;      i[&quot;children&quot;] = [];      OriginResult[PIndex].city.forEach((ii, IN) =&gt; &#123;        // 遍历当前索引下后端数据的city数据        let CIndex = IN++;        i[&quot;children&quot;].push(&#123;          // 插入children数据          title: ii.name,          key: PIndex + &quot;-&quot; + CIndex // 通过0-0作为key，方便后面判断城市和省份的所属关系        &#125;);      &#125;);      navs.push(i);    &#125; else &#123;      // 直辖市对应city就只有一个，为了满足后端接口入参需求      i[&quot;title&quot;] = item.province.name;      i[&quot;key&quot;] = item.province.name;      navs.push(i);    &#125;  &#125;);  this.setState(    &#123;      CityTreeList: this.state.CityTreeList.concat(navs)    &#125;,    () =&gt; &#123;      console.log(this.state.CityTreeList);    &#125;  );&#125;</code></pre><p>现在后端数据已经整合到了 CityTreeList 中，且符合 Ant 的 Tree 组件格式要求。但后端要求入参符合如下格式，意味着我们触发确定接口保存用户所选省份和城市时需要再次遍历勾选内容进行数据重组</p><pre><code>&quot;city&quot;: [  &#123;    &quot;province&quot;: &quot;string&quot;,    &quot;city&quot;: &quot;string&quot;  &#125;]</code></pre><p>Ant 的 Tree 组件有一个 onCheck 属性，会记录用户点击的内容，平铺到 checkedKeys 数组中</p><pre><code class="json">[  &quot;澳门&quot;,  &quot;蚌埠&quot;,  &quot;巢湖&quot;,  &quot;福建&quot;,  &quot;福安&quot;,  &quot;福州&quot;,  &quot;晋江&quot;,  &quot;宁德&quot;,  &quot;泉州&quot;,  &quot;武夷山&quot;]</code></pre><h1 id="将勾选数据处理为后端入参形式"><a href="#将勾选数据处理为后端入参形式" class="headerlink" title="将勾选数据处理为后端入参形式"></a>将勾选数据处理为后端入参形式</h1><pre><code>onCheck = checkedKeys =&gt; &#123;  // console.log(&quot;onCheck&quot;, checkedKeys);  this.setState(&#123; checkedKeys &#125;);  let nav = [];  const &#123; CityTreeList &#125; = this.state;  checkedKeys.forEach(item =&gt; &#123;     CityTreeList.forEach(x =&gt; &#123;       if (x.key === item) &#123;         nav.push(&#123;          province: item,          city: item        &#125;);      &#125; else if (x.children != undefined) &#123;        x.children.forEach(xx =&gt; &#123;          if (xx.key === item) &#123;            nav.push(&#123;              province: x.title,              city: xx.title            &#125;);          &#125;        &#125;);      &#125;    &#125;);  &#125;);  this.setState(    &#123;      city: nav    &#125;,    () =&gt; &#123;      this.props.sendCityData(this.state.city);    &#125;  );&#125;;</code></pre><p>处理后的格式如下</p><pre><code>[&#123; &quot;province&quot;: &quot;澳门&quot;, &quot;city&quot;: &quot;澳门&quot; &#125;, &#123; &quot;province&quot;: &quot;福建&quot;, &quot;city&quot;: &quot;福安&quot; &#125;]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithms</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Taste-Algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人生初半马！</title>
    <link href="undefined2019/09/19/%E4%BA%BA%E7%94%9F%E5%88%9D%E5%8D%8A%E9%A9%AC/"/>
    <url>2019/09/19/%E4%BA%BA%E7%94%9F%E5%88%9D%E5%8D%8A%E9%A9%AC/</url>
    
    <content type="html"><![CDATA[<p>人生初半马！如果没办法停，你就要继续跑！<br>大学老师说过最让我印象深刻的一句话是：“迷茫时，走出寝室、走出教室、走向操场！”</p><p>2019 诸暨西施马拉松（绍兴半程马拉松 21.0975 公里）<br>地点：绍兴市诸暨市（浙江省绍兴市诸暨市城市广场）<br>时间：2019 年 11 月 17 日 07:30<br>比赛路线 :诸暨城市广场 → 浣东北路 → 暨东路 → 环城东路 → 环城北路 → 迎宾路 → 西二环路 → 五纹岭隧道 → 环城南路 → 浣纱南路 → 浣纱大桥 → 浣东中路 → 诸暨城市广场（终点）</p><ul><li>赛事详情：<a href="http://www.zjxsmarathon.com/zjxsmarathon/Index/details/id/1.html">http://www.zjxsmarathon.com/zjxsmarathon/Index/details/id/1.html</a></li></ul><h1 id="赛前训练"><a href="#赛前训练" class="headerlink" title="赛前训练"></a>赛前训练</h1><p><strong>注意：每次训练&#x2F;比赛之前先上厕所把身体的垃圾排空</strong></p><h2 id="热身"><a href="#热身" class="headerlink" title="热身"></a>热身</h2><p>1.关节热身：踝、膝、腰、肩<br>2.慢跑10-15min<br>3.关节操、伸展操</p><h2 id="跑步结束之后的肌群训练"><a href="#跑步结束之后的肌群训练" class="headerlink" title="跑步结束之后的肌群训练"></a>跑步结束之后的肌群训练</h2><p>1.腿肌-&gt;跨步走&#x2F;深蹲（负重）<br>2.腹肌-&gt;V型脚踏车<br>3.背肌-&gt;俯卧打水<br>4.手肌-&gt;俯卧撑</p><h2 id="赛前2个月（量和肌力的训练）"><a href="#赛前2个月（量和肌力的训练）" class="headerlink" title="赛前2个月（量和肌力的训练）"></a>赛前2个月（量和肌力的训练）</h2><ul><li>7k (3次&#x2F;周)</li><li>保持8-9min&#x2F;Km平均配速</li><li>每个礼拜增加1-2公里</li></ul><h2 id="赛前1个月（提高速度）"><a href="#赛前1个月（提高速度）" class="headerlink" title="赛前1个月（提高速度）"></a>赛前1个月（提高速度）</h2><ul><li>赛前前3天调整训练、提升自信心</li></ul><h2 id="配速技巧"><a href="#配速技巧" class="headerlink" title="配速技巧"></a>配速技巧</h2><p>起点(原定配速)-&gt;1&#x2F;2(原定配速)-&gt;3&#x2F;4(视体力调整)-&gt;终点（最后1&#x2F;4，条件允许加速）</p><h1 id="饮食调整"><a href="#饮食调整" class="headerlink" title="饮食调整"></a>饮食调整</h1><h2 id="赛前1周"><a href="#赛前1周" class="headerlink" title="赛前1周"></a>赛前1周</h2><ul><li>提高肌肉肝糖储存量</li><li>前3天 70%高蛋白 10%低碳水</li><li>后3天 低蛋白 高碳水</li><li>赛前1天 高碳水、淀粉</li></ul><h1 id="赛前注意事项"><a href="#赛前注意事项" class="headerlink" title="赛前注意事项"></a>赛前注意事项</h1><h2 id="赛前1天"><a href="#赛前1天" class="headerlink" title="赛前1天"></a>赛前1天</h2><ul><li>熟悉赛道</li></ul><p>⚠️比赛之前的一餐一定要吃</p><h2 id="水分补充"><a href="#水分补充" class="headerlink" title="水分补充"></a>水分补充</h2><ul><li>200cc&#x2F;30分钟（跑步过程中先喝运动饮料、再喝水）</li><li>有水就喝水（第一个饮水站就开始喝水、避免口渴再喝）</li></ul><h1 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h1><h2 id="马拉松报名"><a href="#马拉松报名" class="headerlink" title="马拉松报名"></a>马拉松报名</h2><p>一般都会限额，如本次诸暨西施马拉松3000限额，超过要抽签报名</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>马拉松</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识泰罗奥特曼</title>
    <link href="undefined2019/08/21/%E5%88%9D%E8%AF%86Taro%EF%BC%88%E6%B3%B0%E7%BD%97%E5%A5%A5%E7%89%B9%E6%9B%BC%EF%BC%89/"/>
    <url>2019/08/21/%E5%88%9D%E8%AF%86Taro%EF%BC%88%E6%B3%B0%E7%BD%97%E5%A5%A5%E7%89%B9%E6%9B%BC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="快速搭建了一个泰罗"><a href="#快速搭建了一个泰罗" class="headerlink" title="快速搭建了一个泰罗"></a>快速搭建了一个泰罗</h1><blockquote><p>前提：保证 node 版本&gt;&#x3D;8.0.0</p></blockquote><h2 id="Step1-全局安装-Taro"><a href="#Step1-全局安装-Taro" class="headerlink" title="Step1.全局安装 Taro"></a>Step1.全局安装 Taro</h2><pre><code class="bash">yarn global add @tarojs/cli</code></pre><h2 id="Step2-使用命令创建模板项目"><a href="#Step2-使用命令创建模板项目" class="headerlink" title="Step2.使用命令创建模板项目"></a>Step2.使用命令创建模板项目</h2><pre><code class="bash">taro init MyFirstTaro</code></pre><h2 id="Step3-使用-yarn-安装依赖"><a href="#Step3-使用-yarn-安装依赖" class="headerlink" title="Step3.使用 yarn 安装依赖"></a>Step3.使用 yarn 安装依赖</h2><pre><code class="bash">cd MyFirstTaroyarn</code></pre><h1 id="编译预览及打包"><a href="#编译预览及打包" class="headerlink" title="编译预览及打包"></a>编译预览及打包</h1><p>目前我只需要适配微信小程序，所以只对微信小程序进行编译预览及打包</p><pre><code class="bash">yarn dev:weapp --watch # 添加watch来监听文件修改yarn build:weapp # build 模式：无--watch，将不会监听文件修改，并会对代码进行压缩打包</code></pre><p>如果在编译时想禁用 ESLint 检查，可以在命令前加入 <code>ESLINT=false</code> 参数</p><pre><code class="bash">ESLINT=false taro build --type weapp --watch</code></pre><!-- 此处后期添加一个效果图 --><h1 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h1><h2 id="格式化工具"><a href="#格式化工具" class="headerlink" title="格式化工具"></a>格式化工具</h2><blockquote><p>VsCode 安装好格式化插件 prettierrc 的前提下</p></blockquote><p><strong>.prettierrc.js</strong></p><pre><code class="js">/** * 默认的一些配置 * printWidth: 80, * tabWidth: 2, * useTabs: false * quoteProps:as-needed 对象的属性只有需要时才添加引号 * jsxSingleQuote: false jsx中使用单引号 * trailingComma: none 数组和对象的尾逗号 * bracketSpacing: true 对象左右大括号各有一个空格 &#123; foo: bar &#125; * jsxBracketSameLine: false jsx中标签多行属性的第一个 &gt; 是单独一行还是在行尾 * arrowParens: avoid 箭头函数只有一个参数时，尽可能地省略括号 */module.exports = &#123;  singleQuote: true, // 单引号  semi: false,  arrowParens: &#39;always&#39;,  trailingComma: &#39;es5&#39;, // 是否使用尾逗号，有三个可选值：&lt;none|es5|all&gt;&#125;;// 无分号，箭头函数参数必有括号，尾逗号</code></pre><p><strong>project.config.json 配置</strong><br>Taro 模板创建的项目默认拥有 <code>project.config.json</code> 这一项目配置文件<strong>只用于适配微信小程序</strong>，要适配其他平台要进行相应 json 文件的配置，具体可看<a href="https://nervjs.github.io/taro/docs/project-config.html">Taro 官网-项目配置</a></p><pre><code class="json">&#123;  &quot;miniprogramRoot&quot;: &quot;dist/&quot;,  &quot;projectname&quot;: &quot;MyFirstTaro&quot;,  &quot;description&quot;: &quot;Can&#39;t Tell U&quot;,  &quot;appid&quot;: &quot;wxf694b87c0666666&quot;,  &quot;setting&quot;: &#123;    &quot;urlCheck&quot;: true,    &quot;es6&quot;: false,    &quot;postcss&quot;: false,    &quot;minified&quot;: false,    &quot;coverView&quot;: true,    &quot;babelSetting&quot;: &#123;      &quot;ignore&quot;: [],      &quot;outputPath&quot;: &quot;&quot;    &#125;  &#125;,  &quot;compileType&quot;: &quot;miniprogram&quot;,  &quot;simulatorType&quot;: &quot;wechat&quot;,  &quot;simulatorPluginLibVersion&quot;: &#123;&#125;,  &quot;condition&quot;: &#123;&#125;&#125;</code></pre><h1 id="Taro-页面模板"><a href="#Taro-页面模板" class="headerlink" title="Taro 页面模板"></a>Taro 页面模板</h1><pre><code class="jsx">import Taro, &#123; Component &#125; from &#39;@tarojs/taro&#39;;import &#123; View, Text &#125; from &#39;@tarojs/components&#39;;import &#39;./app.less&#39;;import &#39;./index.less&#39;;class LoginFindpassword extends Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;&#125;;  &#125;  componentWillMount() &#123;    console.log(&#39;this.$router.params&#39;);    console.log(this.$router.params);  &#125;  componentDidMount() &#123;&#125;  componentDidHide() &#123;&#125;  componentDidShow() &#123;&#125;  // 项目配置  config = &#123;    navigationBarTitleText: &#39;忘记密码&#39;,  &#125;;  // JS方法  render() &#123;    const &#123;&#125; = this.props;    const &#123;&#125; = this.state;    return (      &lt;View className=&#39;page&#39;&gt;        &lt;Text&gt;Hello Taro&lt;/Text&gt;      &lt;/View&gt;    );  &#125;&#125;export default LoginFindpassword;</code></pre><h1 id="与微信小程序原生写法的常见不同写法"><a href="#与微信小程序原生写法的常见不同写法" class="headerlink" title="与微信小程序原生写法的常见不同写法"></a>与微信小程序原生写法的常见不同写法</h1><ul><li><code>bindfocus</code> 改用 <code>onFocus</code> 替代</li></ul><pre><code class="jsx">&lt;Input bindfocus=&#123;this.onFocus&#125; /&gt;  =&gt; &lt;Input onFocus=&#123;this.onFocus&#125; /&gt;</code></pre><ul><li><code>bindtap</code> 改用 <code>onClick</code> 替代</li></ul><pre><code class="jsx">&lt;View bindtap=&#123;this.onTag&#125; /&gt; =&gt; &lt;View onClick=&#123;this.onTag&#125; /&gt;</code></pre><ul><li><code>animationEnd</code> 改用 <code>onAnimationEnd</code> 替代</li></ul><pre><code class="jsx">&lt;CustomElement animationEnd=&#123;this.data.onAnimationEnd&#125; /&gt; =&gt; &lt;CustomElement onAnimationEnd=&#123;this.state.onAnimationEnd&#125; /&gt;</code></pre><ul><li>bindchange 该用 onChange 替代</li><li>placeholder&#x3D;””改用 placeholder&#x3D;{} 替代</li><li>maxlength&#x3D;”15”改用 maxLength&#x3D;{15}替代</li><li>scroll-view 改为 ScrollView</li><li>input 中<code>password</code>改写为<code>&lt;Input password=&#123;true&#125; /&gt;</code></li><li><code>bindinput</code>改写为<code>onInput</code></li><li><code>cover-View</code>改写为<code>CoverView</code></li><li><code>&lt;block&gt;...&lt;/block&gt;</code>改写为<code>&lt;Block&gt;...&lt;/Block&gt;</code></li><li><code>&lt;picker&gt;...&lt;/picker&gt;</code>改写为<code>&lt;Picker&gt;...&lt;/Picker&gt;</code></li><li><code>wx:if=&#123;IdCardType == 1010106&#125;</code>改为<code>&#123;IdCardType === 1010106 &amp;&amp; (...)&#125;</code></li><li><code>this.setData</code>改为<code>this.setState</code></li><li>在小程序里对应的生命周期是 onLoad 在 Taro 中对应 componentWillMount()这一块</li><li>onLoad 中的 query 改为路由传参<code>this.$router.params</code></li><li>在小程序里对应的生命周期是 onShow 在 Taro 中对应 componentDidShow()这一块</li><li>在小程序里对应的生命周期是 onLaunch 在 Taro 中对应 componentDidMount()这一块(在 componentWillMount 后执行)<br>监听程序初始化，初始化完成时触发（全局只触发一次）</li><li>页面退出时在小程序里对应的生命周期是 onUnload 在 Taro 中对应 componentWillUnmount()这一块</li><li>动态修改 title：</li></ul><pre><code>Taro.setNavigationBarTitle(&#123;  title: &#39;登录&#39;&#125;);</code></pre><ul><li>使用<code>map</code>方法替换成小程序中<code>wx:for</code>,且要注意 Taro 中 map 后索引通过 map(item,index)后给对应事件通过 bind(this,index)的方式获取索引 index，而不能使用小程序常用的自定义方法’data-xxx’  <!-- - `AppIdentity: function ()`改为`AppIdentity=()=>` --><strong>微信原生</strong></li></ul><pre><code class="js">&lt;view className=&quot;route-list&quot; wx:for=&#123;orderList&#125; wx:for-item=&quot;order&quot; bindtap=&quot;routeChoosedTap&quot; data-id=&#123;index&#125; wx:key=&quot;orderList&quot;&gt;  &#123;&#123;order.test&#125;&#125;&lt;/view&gt;</code></pre><p><strong>Taro</strong></p><pre><code class="js">&#123;  orderList.map((order, index) =&gt; &#123;    return (      &lt;View        className=&#39;route-list&#39;        onClick=&#123;this.routeChoosedTap&#125;        data-id=&#123;index&#125;        taroKey=&#39;orderList&#39;      &gt;        &#123;order.test&#125;      &lt;/View&gt;    );  &#125;);&#125;</code></pre><ul><li>taroKey 替换微信小程序的 wx:key，用于循环渲染原生小程序组件，赋予每个元素唯一确定标识</li></ul><p><strong>原生</strong></p><pre><code class="jsx">&lt;view wx:key=&#123;statusArr&#125;&gt;&#123;item.message&#125;&lt;/view&gt;</code></pre><p><strong>Taro</strong></p><pre><code class="jsx">&lt;view taroKey=&#123;statusArr&#125;&gt;&#123;item.message&#125;&lt;/view&gt;</code></pre><h1 id="你不得不避免的坑"><a href="#你不得不避免的坑" class="headerlink" title="你不得不避免的坑"></a>你不得不避免的坑</h1><h2 id="因为-setState-异步导致的问题"><a href="#因为-setState-异步导致的问题" class="headerlink" title="因为 setState 异步导致的问题"></a>因为 setState 异步导致的问题</h2><p>this.data.orderList &#x3D; []时会直接操作 data 中的数据，而 React 语法使用 setState 是有延时的，所以要放在 setState 的会提到中执行</p><blockquote><p>场景：<br>登录成功则通过 Taro.setStorage 缓存一个 key，并将 hasLogin 设置为 true<br>首页通过 getStorage 来获取指定 key 来判断是否登录成功<br>如果在 complete 中通过 setState 更新 hasLogin，但 setState 是异步操作，所以 getStorage 事件里获取的 hasLogin 还是 false，所以页面登录进去又会跳回登录页面(login&#x2F;index)！</p></blockquote><pre><code class="js">Taro.getStorage(&#123;  key: &#39;User&#39;,  success: function (res) &#123;    if (res.data) &#123;      globalData.User = res.data;      console.log(&#39;成功得到key&#39;);      that.setState(&#123;        hasLogin: true,      &#125;);    &#125;  &#125;,  complete: function () &#123;    // 无论接口调用结束的回调函数    if (!that.state.hasLogin) &#123;      console.log(&#39;Test3&#39;);      console.log(that.state.hasLogin);      Taro.redirectTo(&#123;        url: &#39;../login/index&#39;,      &#125;);    &#125;  &#125;,&#125;);</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>不在 complete 回调中使用路由跳转方法，转而放到 componentDidMount()生命周期中执行判断</p><pre><code class="js">componentDidMount() &#123;  if (!that.state.hasLogin) &#123;    console.log(&quot;Test3&quot;);    console.log(that.state.hasLogin);    Taro.redirectTo(&#123;      url: &quot;../login/index&quot;    &#125;);  &#125;&#125;</code></pre><h2 id="要使用-stopPropagation-来取代-catchtap-阻止冒泡"><a href="#要使用-stopPropagation-来取代-catchtap-阻止冒泡" class="headerlink" title="要使用 stopPropagation 来取代 catchtap 阻止冒泡"></a>要使用 stopPropagation 来取代 catchtap 阻止冒泡</h2><p><strong>微信小程序写法</strong></p><pre><code class="js">toggleDialog:function() &#123;  this.setData(&#123;    showDialog: false,  &#125;)&#125;&lt;View className=&#39;item-bd&#39; catchtap=&#39;toggleDialog&#39;&gt;  &#123;personCenter[yuyan].cancel&#125;&lt;/View&gt;</code></pre><p><strong>Taro 写法</strong></p><pre><code class="js">toggleDialog = (e) =&gt; &#123;  e.stopPropagation();  this.setState(&#123;    showDialog: false,  &#125;);&#125;;&lt;View className=&#39;item-bd&#39; onClick=&#123;this.toggleDialog&#125;&gt;  &#123;personCenter[yuyan].cancel&#125;&lt;/View&gt;;</code></pre><h2 id="本地资源引入"><a href="#本地资源引入" class="headerlink" title="本地资源引入"></a>本地资源引入</h2><p><a href="https://nervjs.github.io/taro/docs/static-reference.html#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A0%B7%E5%BC%8F%E4%B8%AD%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90">小程序样式中引用本地资源</a></p><p>本地 config 文件夹下的 index.js 保持和 Taro 官网中一样的配置，但是使用<code>import note from &#39;../../images/path/note.png</code>仍然报错<code>Failed to load local image resource</code>，仔细检查发现路径也没有任何问题</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>js 中引入本地图片，Taro 无法对其进行转换</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p><strong>在 css 里引入图片</strong></p><pre><code class="css">.note &#123;  background-image: url(../../images/note.png);&#125;</code></pre><h2 id="currentTarget-获取索引的-Taro-写法与微信小程序写法异同"><a href="#currentTarget-获取索引的-Taro-写法与微信小程序写法异同" class="headerlink" title="currentTarget 获取索引的 Taro 写法与微信小程序写法异同"></a>currentTarget 获取索引的 Taro 写法与微信小程序写法异同</h2><p>场景：后端给出一个数组，数组中的数据依次渲染到列表中，用户点击对应的数据要拿到对应的索引进行操作<br><strong>微信小程序写法</strong></p><blockquote><p>通过 currentTarget 事件绑定的当前组件，dataset 属性结合自定义属性组成的集合 data-xxx</p></blockquote><pre><code class="js">//查看审核流程showCheckModal: function(e)&#123;  var that = this;  var id = e.currentTarget.dataset.id;  that.setData(&#123;    showCheck: true,    modalList: that.data.orderList[id].ApproveSteps  &#125;)&#125;,&lt;view catchtap=&quot;showCheckModal&quot; wx:if=&quot;&#123;&#123;order.ApproveSteps.length > 0 &#125;&#125;&quot; data-id=&quot;&#123;&#123;index&#125;&#125;&quot;&gt;&lt;/view&gt;</code></pre><p><strong>Taro 写法</strong></p><blockquote><p>通过 map 将数据遍历渲染，然后通过 bind 将数据的索引传递给绑定事件</p></blockquote><pre><code class="js">//查看审核流程showCheckModal = (index, e) =&gt; &#123;  let id = index;  this.setState(&#123;    showCheck: true,    modalList: this.state.orderList[id].ApproveSteps,  &#125;);&#125;;&#123;  orderList.length &gt; 0 &amp;&amp;    orderList.map((order, i) =&gt; &#123;      return (        &lt;View          className=&#39;approveStatus&#39;          onClick=&#123;this.showCheckModal.bind(this, i)&#125;        &gt;          &lt;View&gt;&#123;Itinerary[yuyan].viewPro&#125;&lt;/View&gt;        &lt;/View&gt;      );    &#125;);&#125;</code></pre><h1 id="Taro-调用上一个页面方法"><a href="#Taro-调用上一个页面方法" class="headerlink" title="Taro 调用上一个页面方法"></a>Taro 调用上一个页面方法</h1><p>关键：<code>.$component.</code></p><pre><code class="jsx">// 返回到个人信息Taro.showToast(&#123;  title: msg,  icon: &#39;none&#39;,  duration: 2000,  success: function () &#123;    let pages = Taro.getCurrentPages();    let prevPage = pages[pages.length - 2];    prevPage.$component.setState(      &#123;        userEmail: email,      &#125;,      () =&gt; &#123;        console.log(&#39;页面回退&#39;);        Taro.navigateBack(&#123;          delta: 1,          complete: function () &#123;            prevPage.$component.getBaseInfo(globalData.User.UserId);          &#125;,        &#125;);      &#125;    );  &#125;,&#125;);</code></pre><h1 id="开发注意事项"><a href="#开发注意事项" class="headerlink" title="开发注意事项"></a>开发注意事项</h1><ul><li>在 Taro 默认生成的模板都推荐用 ESLint 进行检测</li><li>小程序不支持将 data 中任何一项的 value 设为 <code>undefined</code>，setState 时用<code>null</code>来代替 <code>undefined</code></li><li>Taro 中，JS 代码里必须书写单引号,双引号会导致编译错误</li><li>双重嵌套遍历时每层的 index 都要写出来，详情<a href="https://nervjs.github.io/taro/docs/debug.html">Debug 指南-编译模板出错</a></li></ul><h1 id="如何快速重构"><a href="#如何快速重构" class="headerlink" title="如何快速重构"></a>如何快速重构</h1><p>同样的内容同时开发，就是高效解决问题的办法！划分合并的思想！</p><ol><li>写入 Taro 页面模板</li><li>写入 wxml</li></ol><p>&#96;&#96;&#96;</p><ul><li><code>&quot;&#123;&#123;` 改为 `&#123;`- `&#123;&#123;` 改为 `&#123;`- `&#125;&#125;&quot;</code> 改为 <code>&#125;</code></li><li>}} 改为 }</li><li>&lt;view 改为&lt;View</li><li>class&#x3D;”改为 className&#x3D;’</li><li>className 的模版字符串引入</li><li>style&#x3D;”改为 style&#x3D;</li></ul>]]></content>
    
    
    <categories>
      
      <category>快乐编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React 那些事儿</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手把手教你新建一个Vue项目</title>
    <link href="undefined2019/08/20/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AAVue%E9%A1%B9%E7%9B%AE/"/>
    <url>2019/08/20/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AAVue%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<!-- 原始笔记在‘Vue-Study文件夹下修改，再来此处更新！’ --><h1 id="下载安装-node-js"><a href="#下载安装-node-js" class="headerlink" title="下载安装 node.js"></a>下载安装 node.js</h1><p><a href="http://nodejs.cn/">node 官网下载地址</a><br>控制台输入 node-v 检查自己系统有没有下载过 node<br>使用 npm 包管理工具，推荐去国内最常用的库：<a href="https://cnpmjs.org/">https://cnpmjs.org</a><br>国内用户在终端执行以下代码替换淘宝镜像进行下载，换成了淘宝了镜像，在国内网速很快。</p><pre><code>alias cnpm=&quot;npm --registry=https://registry.npm.taobao.org \--cache=$HOME/.npm/.cache/cnpm \--disturl=https://npm.taobao.org/mirrors/node \--userconfig=$HOME/.cnpmrc&quot;</code></pre><blockquote><p>alias（别名）的一串命令将 npm 重命名为 cnpm</p></blockquote><h1 id="安装-vue-cli-vue-cli-是-vue-官方提供的脚手架工具"><a href="#安装-vue-cli-vue-cli-是-vue-官方提供的脚手架工具" class="headerlink" title="安装 vue-cli(vue-cli 是 vue 官方提供的脚手架工具)"></a>安装 vue-cli(vue-cli 是 vue 官方提供的脚手架工具)</h1><h2 id="用-vue-cli-初始化项目的优势："><a href="#用-vue-cli-初始化项目的优势：" class="headerlink" title="用 vue-cli 初始化项目的优势："></a>用 vue-cli 初始化项目的优势：</h2><ul><li>成熟的 vue 项目架构设计</li><li>本地测试服务器</li><li>集成 webpack 打包上线方案</li></ul><h2 id="安装系统要求："><a href="#安装系统要求：" class="headerlink" title="安装系统要求："></a>安装系统要求：</h2><ul><li>Node.js(&gt;&#x3D;4.x)</li><li>Git</li><li>一个能使用 node 的命令行终端</li></ul><h2 id="全局安装-Vue-cli"><a href="#全局安装-Vue-cli" class="headerlink" title="全局安装 Vue-cli"></a>全局安装 Vue-cli</h2><p>npm install vue-cli -g</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><blockquote><p>在自己项目文件夹下打开控制台</p></blockquote><h2 id="安装-webpack-模板，并设置工程信息"><a href="#安装-webpack-模板，并设置工程信息" class="headerlink" title="安装 webpack 模板，并设置工程信息"></a>安装 webpack 模板，并设置工程信息</h2><p>vue init webpack my-project [my-project 为项目名称]<br>控制台需要设置如下问题<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/Create-Vue-1-20190820.png"></p><ul><li>Project name：项目名称，默认是输入时的那个名称，想改的话直接输入修改，也可以直接回车</li><li>Install vue-router:是否需要 vue-router，这里默认选择使用，这样生成好的项目就会有相关的路由配置文件</li><li>Use ESLint to lint your code:是否使用 ES 检测器，默认使用，这样会生成相关的 ESLint 配置</li><li>Setup unit tests with Karma + Moch?: 是否安装单元测试。一般选 no，根据自己项目情况选择”Y”或”N”</li><li>Setup e2e tests with Nightwatch：是否安装 e2e 测试。一般也选 no，根据自己项目情况选择”Y”或”N”<br>以上配置如选择 yes 则生成的项目会自动有相关的配置，有一些 loader 我们就要配套下载。<br>如果我们确定不用的话最好不要 yes，防止下很多没有用的 loader。</li></ul><h2 id="部署-Vue-项目完成之后的目录"><a href="#部署-Vue-项目完成之后的目录" class="headerlink" title="部署 Vue 项目完成之后的目录"></a>部署 Vue 项目完成之后的目录</h2><ul><li><p>首页入口 index.html</p></li><li><p>build 配置文件夹</p></li><li><p>webpack.base.config.js、webpack.dev.config.js、webpack.prod.config.js 三个 webpack 的配置文件，分别是基本 webpack 配置、开发环境配置、生产环境配置。</p></li><li><p>config 配置文件夹<br>其中最主要的 index.js 用于配置代理服务器，和后台联调时在 proxyTable 这个属性设置一个后台地址即可。<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/Create-Vue-2-20190820.png"></p></li><li><p>src 文件夹（主要以及使用频率最高的文件夹、大部分开发在 src 目录下、存储主要源码）<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/Create-Vue-3-20190820.png"></p></li><li><p>assets: 共用的样式、图片</p></li><li><p>components: 业务代码存放位置、里面分成一个个组件存放，一个页面是一个组件，一个页面里面还会包着很多组件</p></li><li><p>router: 设置路由</p></li><li><p>App.vue: vue 文件入口界面，App.vue 是可以热更新的。</p></li><li><p>main.js：入口文件、对应 App.vue 创建 vue 实例，对应 webpack.base.config.js 里的入口配置</p></li><li><p>static 文件夹（保存静态文件）<br>存放的文件不会经过 webpack 处理，可直接引用<br>如 swf 文件要引用可在 webpack 配置带 swf 后缀名的文件处理的 loader，也可直接将 swf 文件放在这个文件夹引用</p></li><li><p>package.json（npm 所需要的一套配置文件）<br>这个文件有两部分是有用的：</p><ul><li>scripts 里面设置命令，<br>如设置了 dev 用于调试则我们开发时输入：npm run dev</li><li>如设置了 build 输入<br>npm run build 用于打包会生成部署一套上线目录文件（完成之后多了 dist 目录）<br>我们需要的依赖包,在 dependencies 和 devDependencies 中，分别对应全局下载和局部下载的依赖包</li></ul></li></ul><h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><ul><li>进入项目文件夹：cd my-project</li><li>打开 package.json 文件，找到 devDependencies 和 dependencies，删掉里面我们不需要的依赖包</li><li>根据自己项目需要通过命令 sudo npm install &#x2F;npm install（安装项目依赖）、下载其他依赖包如 npm install vue-resource 等，一个个下载<blockquote><p>要在有 packge.json 文件的目录下、推荐使用 yarn，速度更快、相关依赖安装之后目录会多一个 node_modules</p></blockquote></li></ul><h1 id="跑项目-npm-run-dev"><a href="#跑项目-npm-run-dev" class="headerlink" title="跑项目 npm run dev"></a>跑项目 npm run dev</h1><ul><li><p>下载好依赖后先输入 npm install</p></li><li><p>如有缺漏再根据提示去下载。</p></li><li><p>输入命令 sudo npm run dev &#x2F; npm run dev(在本地启动测试服务器)<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/Create-Vue-4-20190820.png"></p><blockquote><p>ESLint: 帮助检查 Javascript 编程时的语法错误，保证多人开发一个项目保持语法一致。<br>Webpack: 设置代理、插件和 loader 处理各种文件和相关功能、打包等功能。整个项目中核心配置<br>iview: 基于 vue 的一套样式框架，里面有很多封装好的组件样式<br>ES6 语法：利用 babel 处理。<br>vue –help vue 的命令行查看帮助<br>vue -v 看版本</p></blockquote></li></ul><h1 id="步骤总结："><a href="#步骤总结：" class="headerlink" title="步骤总结："></a>步骤总结：</h1><ul><li>npm install –global vue-cli 下载 vue-cli 脚手架</li><li>vue init webpack myProject 生成项目，形成基本结构</li><li>npm install 下载依赖包</li><li>npm run dev 运行</li></ul><h1 id="项目实例"><a href="#项目实例" class="headerlink" title="项目实例"></a>项目实例</h1><p>build&#x2F;webpack.base.config.js<br>进行 loader 的配置，以及有一个 iview 的 css 文件不进行 babel 的处理，如下<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/Create-Vue-5-20190820.png"><br>src&#x2F;router&#x2F;index.js:<br>import 引入组件文件，根据 vue-router 写上相应的路由配置</p><p>src&#x2F;components:<br>业务代码集中地，我做了一个简单的，只有三个组件。然后在每个组件中又分成几个组件构成。<br><img src="https://github.com/EdisonVan/GraphBed/raw/master/Create-Vue-6-20190820.png"></p><!-- -----------------后期再来更新项目实例文档，觉得文章写的不错可扫码募捐以鼓励我继续书写高质量的原创文章。 -->]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>低成本快速搭建个人博客</title>
    <link href="undefined2019/08/06/HexoBlog-20190704/"/>
    <url>2019/08/06/HexoBlog-20190704/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最小的成本搭建一个有自己域名的博客站点（Hexo 生成页面，托管于 GitHub，使用自己的域名，可以安心写作又不用花费很多心思定期维护）</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>一个博客网站模板：Hexo&#x2F;Jekyll&#x2F;vuePress（这里我选用了 Hexo）</li></ol><blockquote><p>主要涉及知识点：linux 基础命令，mysql 基础操作</p></blockquote><ol start="2"><li>购买自己的域名（建议）</li></ol><ul><li>百度不收录<code>.github.io</code>结尾的站点，直接使用 GitHub 托管的话，用户在百度上无法搜到自己站点上的内容；</li><li>有 SSL（网址前面的 https:&#x2F;&#x2F;）比没有会在搜索引擎的排名中更加靠前</li><li>在内容相同的情况下，有着自己的域名更加利于 SEO(搜索引擎的优化)</li></ul><h2 id="Blog-框架："><a href="#Blog-框架：" class="headerlink" title="Blog 框架："></a>Blog 框架：</h2><p><a href="https://hexo.io/">hexo 官网</a></p><h3 id="hexo-的特点"><a href="#hexo-的特点" class="headerlink" title="hexo 的特点"></a>hexo 的特点</h3><ul><li>支持 Markdown: 支持 Markdown 意味着你可以把精力从排版中解放出来.</li><li>轻量: 无需拥有后台及数据库,专心写好你的文章</li><li>一键部署: 可以通过 Git 或者 ftp 来将生成的静态页面部署到服务器或者主机空间中</li><li>插件丰富: 丰富的插件可以满足你的各种需求.</li></ul><h3 id="hexo-的工作机制"><a href="#hexo-的工作机制" class="headerlink" title="hexo 的工作机制"></a>hexo 的工作机制</h3><ul><li>基于 Node.js,将&#x2F;source 文件夹下的资源(文章,图片,模板),按照预定的配置文件,转换成静态页面放置到&#x2F;public 目录下.</li><li>如果需要预览或者部署,hexo 会把 public 作为 web 目录处理.</li></ul><h3 id="Hexo-安装所需环境"><a href="#Hexo-安装所需环境" class="headerlink" title="Hexo 安装所需环境"></a>Hexo 安装所需环境</h3><ul><li>Node.js</li><li>git</li></ul><h3 id="Tip-⚠️"><a href="#Tip-⚠️" class="headerlink" title="Tip ⚠️"></a>Tip ⚠️</h3><p>博客目录有全局 config.yml，在每个 theme 主题中也有一个 config.yml，对应的不同工作！</p><ul><li>Hexo 配置文件:<code>myblog/config.yml</code></li><li>主题配置文件:<code>myblog/themes/next/config.yml</code></li></ul><h2 id="开始搭建"><a href="#开始搭建" class="headerlink" title="开始搭建"></a>开始搭建</h2><!-- ![CreateABlog](assets/CreateABlog.gif) --><p><img src="https://github.com/EdisonVan/GraphBed/raw/master/CreateABlog-20190730.gif" alt="操作流程图"></p><ol><li>安装 Hexo</li></ol><p>推荐<code>yarn global add hexo</code>来全局安装 Hexo.（保证 NodeJS 已经安装好的情况下）</p><p>Yarn&#x2F;npm 全局安装和本地安装的区别:</p><ul><li>全局安装会把 package 存放在用户目录指定的目录下</li><li>本地安装则是存放在当前项目的 node_module 目录中</li></ul><ol start="2"><li>创建站点目录</li></ol><ul><li>2.1 新建一个空文件夹<code>MyBlog</code>（将作为 hexo 站点目录）并初始化博客</li></ul><pre><code class="js">$ hexo init MyBlog</code></pre><ul><li>2.2 进入 MyBlog 文件夹安装相关依赖</li></ul><pre><code class="js">$ cd MyBlog$ npm install</code></pre><ol start="3"><li>用<code>hexo s</code>在本机运行后来看一下默认的效果</li><li>在 <code>source/_posts/</code> 目录下创建文章 或通过 <code>hexo new post-title（文章 markdown 的名字）</code> 创建新文章，步骤如下：</li></ol><p>例.<br>创建一个名为 <code>宏彦获水</code> 的文章，可以在上述目录下创建一个文件，名为<code>宏彦获水.md</code></p><pre><code class="js">---title: 宏彦获水date: 2019-07-26 22:32:51tags:- 热门时事---全球极客挚爱的高质量技术成长平台，想要学习和提升专业能力从这里开始，充足技术干货等你来啃，轻松拿下 李彦宏亮相百度第三届AI开发者大会，在李彦宏专注介绍百度AI成绩时，一位男子直接冲上舞台泼水。李彦宏先是一愣，后来用英语问到：What’s your problem？...</code></pre><p>刷新页面，就可以看到这篇文章啦</p><p><img src="https://github.com/EdisonVan/GraphBed/raw/master/NewPost-20190730.png" alt="CreateABlog"></p><h2 id="主题样式"><a href="#主题样式" class="headerlink" title="主题样式"></a>主题样式</h2><p>在<a href="https://hexo.io/themes/">Themes | Hexo</a>中有非常多的主题可以供选择：</p><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><ul><li>将主题所在的 GitHub 仓库 clone 到自己的博客的 themes 目录下，在 <code>config.yml</code> 中修改以下字段为主题所在的文件夹名称即可：</li></ul><pre><code class="js">theme: landscape;</code></pre><p>也可以考虑自建一个主题，或从其他博客平台上移植一个主题过来</p><h3 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h3><p>对标题做修改只需要修改博客根目录下的<code>_config.yml</code> 即可，部分文件内容如下：</p><pre><code class="js">title: Peng Sifan # 这里写博客的标题subtitle: It&#39;s my whole life! # 可以理解为博客的副标题description: Peng Sifan&#39;s self blog!keywords:author: Edison Vanlanguage: zh-CNtimezone:# URL## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;url: http://yoursite.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:</code></pre><h2 id="发布站点"><a href="#发布站点" class="headerlink" title="发布站点"></a>发布站点</h2><p>使用<code>GitHub</code>来托管我们的站点</p><ul><li>创建一个 <code>GitHub</code> 仓库用来存放我们的博客，<code>GitHub</code> 的仓库名称为<code>&lt;你的用户名&gt;.github.io</code></li><li>安装 Hexo 的 Git 发布（部署）模块：<code>npm install hexo-deployer-git --save</code></li><li>在 <code>config.yml</code> 中加入以下部分：</li></ul><pre><code>deploy:  type: git  repo: https://github.com/EdisonVan/EdisonVan.github.io.git  branch: master  message: Blog Update  name: EdisonVan  email: vanjohnson@foxmail.com</code></pre><p>⚠️repo 后接你 GitHub 仓库的 SSH 地址或者 HTTPS 地址，这里我用的 HTTPS 地址，因为我公司网络无法访问 SSH 地址。😢<br>SSH 地址格式：<a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#99;&#111;&#109;">&#x67;&#x69;&#116;&#x40;&#103;&#105;&#116;&#104;&#117;&#98;&#x2e;&#99;&#111;&#109;</a>:&lt;用户名&gt;&#x2F;&lt;仓库名称&gt;.git</p><h2 id="开始发布"><a href="#开始发布" class="headerlink" title="开始发布"></a>开始发布</h2><pre><code class="js">hexo clean # 清理之前public的文件hexo g # 重新渲染所有页面为 HTMLhexo d # 发布！</code></pre><p><img src="https://github.com/EdisonVan/GraphBed/raw/master/selfBlog-20190730.png" alt="selfBlog.png"></p><blockquote><p>如果使用<code>hexo clean</code>会清理 public 里面的所有文件进行重新生成，而 public 中的文件实际上就是 userName.github.io 仓库中生成博客页面的文件，所以对应的 CHAME 文件也会被清除，所以小改动暂时不使用 hexo clean。大改动 clean 之后需要再去 public 中添加 CHAME 文件。<br>CNAME 的文本文件，CNAME 文件没有后缀，里面写入你要绑定的域名，比如<code>www.pengsifan.com</code><br>注意 CNAME 文件里面的网址写完整，和你自己解析设置的一致，如我的解析中主机记录加了 www 所以我的 CNAME 文件内就写成了<code>www.pengsifan.com</code></p></blockquote><h2 id="设置自己的域名解析"><a href="#设置自己的域名解析" class="headerlink" title="设置自己的域名解析"></a>设置自己的域名解析</h2><p>如果没有填写<code>Custom domain</code>你的站点地址将会是<code>&lt;GitHub 用户名&gt;.github.io</code>，如果有自己的域名且希望使用的话，就在<code>source 目录</code>下放一个名为 CNAME 的文件（对，没有任何后缀名），内容只有一行，就是自己的域名，将自己的域名做一个<code>CNAME</code>解析到<code>&lt;GitHub 用户名&gt;.github.io</code>地址即可</p><p><img src="https://github.com/EdisonVan/GraphBed/raw/master/GitHub-Page-20190704.png" alt="GitHub-Page-20190704"></p><h1 id="博客的维护与更新"><a href="#博客的维护与更新" class="headerlink" title="博客的维护与更新"></a>博客的维护与更新</h1><p>静态的博客，且有 GitHub 进行托管，所以博客在程序的维护方面就省了很多的事情，让我们可以更加专注于内容和样式上的细节。<br>更新与内容<br>一个博客的灵魂在于博客的内容，如：</p><ul><li>技术的记录（类似日志，方便以后自己查询）</li><li>想法（对于生活的感悟，结交更多的朋友）</li><li>创作（作为一个自平台对于自己创作的发布）</li><li>力扣题解（记录做题目时的想法思路）</li><li>读书心得</li><li>前端</li><li>Python 学习笔记</li><li>Vlog 链接<br>参考<a href="https://support.leetcode-cn.com/hc/kb/article/1277893/">如何撰写 LeetCode 题解</a><br>每当自己有想法时，都可以将自己的想法总结成文发布于博客上。博客的编写是一个熟能生巧的过程，写得越多，对文字的把握就越好，也更加容易在书面上正确地表达自己的想法。无论从结交朋友，收割<code>Offer</code>还是其他方面都是百利而无一害的</li></ul><h2 id="文章书写"><a href="#文章书写" class="headerlink" title="文章书写"></a>文章书写</h2><p>使用 <code>VsCode</code>&#x2F;<code>Typora</code> 书写</p><h2 id="自建主题"><a href="#自建主题" class="headerlink" title="自建主题"></a>自建主题</h2><p>使用<a href="http://caibaojian.com/vuepress/guide/">vuepress</a>搭建网站</p><h2 id="图床方案"><a href="#图床方案" class="headerlink" title="图床方案"></a>图床方案</h2><p><a href="https://toolinbox.net/iPic/">ipic</a> + <a href="https://portal.qiniu.com/signup">七牛云（每月 10G 免费流量）</a> + ipic mover(图床搬家工具)</p><p>GitHub 图床</p><ul><li><a href="https://www.cnblogs.com/ssgeek/p/10854839.html"></a></li><li><a href="https://www.jianshu.com/p/ebed904d852d"></a></li><li><a href="https://blog.csdn.net/cnds123321/article/details/85268444"></a></li></ul><blockquote><p>因为图片走 oss 和 cdn 网站打开速度会很快，所以使用七牛云或者阿里云都是一个不错的方案！七牛云每个月 10g 免费流量基本够用！</p></blockquote><p>对象存储<br>七牛云，阿里云也有对象存储的功能，主要生产缩略图，生成水印各种的非常方便，并且人家的对象存储有 cdn 加速</p><p><a href="https://github.com/EdisonVan/EdisonVan.github.io">🌟 赏颗星星吧！🌟</a></p><!-- 主要涉及知识点：linux基础命令，mysql基础操作 -->]]></content>
    
    
    
    <tags>
      
      <tag>编码之外</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不得不知道的Git插件1--git history</title>
    <link href="undefined2019/07/30/git-history/"/>
    <url>2019/07/30/git-history/</url>
    
    <content type="html"><![CDATA[<blockquote><p>该系列贴子只分享 vs code 插件，如果您的编译器不是 vs code 可以选择看看其他的博客！😂</p></blockquote><p>###<a href="https://github.com/DonJayamanne/gitHistoryVSCode">Git History, Search and More</a></p><h2 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h2><p>VsCode 上通过快捷键<strong>⌘+⇧+X</strong>打开 Extensions 搜索 Git History 进行下载</p><h2 id="二、打开方式"><a href="#二、打开方式" class="headerlink" title="二、打开方式"></a>二、打开方式</h2><p>1.选中文件-右键- <code>Git:View File History</code></p><p>2.F1 输入<br><code>Git:View History(Git log)</code> 查看所有分支的历史记录<br><code>Git:View File History</code> 查看文件的历史记录<br><code>Git:View Line History</code> 查看单行历史变更记录（不常用）</p><h2 id="三、常用功能"><a href="#三、常用功能" class="headerlink" title="三、常用功能"></a>三、常用功能</h2><h2 id="3-1-对比"><a href="#3-1-对比" class="headerlink" title="3.1 对比"></a>3.1 对比</h2><h3 id="本地代码与当前版本代码对比"><a href="#本地代码与当前版本代码对比" class="headerlink" title="本地代码与当前版本代码对比"></a>本地代码与当前版本代码对比</h3><p><img src="https://i.loli.net/2019/04/02/5ca309c7f0bb3.gif" alt="本地与当前版本对比-20190402"><br>左侧为本地代码，右侧为工作区代码</p><h3 id="当前版本号与上一个版本号对比"><a href="#当前版本号与上一个版本号对比" class="headerlink" title="当前版本号与上一个版本号对比"></a>当前版本号与上一个版本号对比</h3><p><img src="https://i.loli.net/2019/04/02/5ca30a39ccb03.gif" alt="不同版本对比-20190402"><br>左侧为当前选中版本，右侧为上一个版本</p><h3 id="不同版本号对比"><a href="#不同版本号对比" class="headerlink" title="不同版本号对比"></a>不同版本号对比</h3><p><img src="https://i.loli.net/2019/04/02/5ca30a47dd256.gif" alt="不同版本号对比-20190402"></p><h2 id="3-2-查看"><a href="#3-2-查看" class="headerlink" title="3.2 查看"></a>3.2 查看</h2><h3 id="查看每一个作者的提交记录"><a href="#查看每一个作者的提交记录" class="headerlink" title="查看每一个作者的提交记录"></a>查看每一个作者的提交记录</h3><p><img src="https://i.loli.net/2019/04/02/5ca30a6bb3d4a.gif" alt="查看不同作者提交-20190402"></p><h3 id="查看不同分支"><a href="#查看不同分支" class="headerlink" title="查看不同分支"></a>查看不同分支</h3><p><img src="https://i.loli.net/2019/04/02/5ca30a5fa7639.gif" alt="查看不同分支-20190402"></p><h2 id="四、其他功能"><a href="#四、其他功能" class="headerlink" title="四、其他功能"></a>四、其他功能</h2><p>恢复提交、从提交创建分支、在树视图中查看提交信息（所有更改的快照）、合并和变革、比较分支<br><img src="https://i.loli.net/2019/04/02/5ca30a7e4bbfd.gif" alt="其他-20190402"></p><blockquote><p>大四实习中，如有写错的地方请大家留言指出，万分感谢。转载请注明出处。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>开发工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Best Time to Buy and Sell Stock</title>
    <link href="undefined2018/12/10/BestTimeToBuyAndSellStock/"/>
    <url>2018/12/10/BestTimeToBuyAndSellStock/</url>
    
    <content type="html"><![CDATA[<h1 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121 Best Time to Buy and Sell Stock"></a>121 Best Time to Buy and Sell Stock</h1><p>Related:Array &amp;&amp; Dynamic Programming<br>Say you have an array for which the ith element is the price of a given stock on day i.<br>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.<br>Note that you cannot sell a stock before you buy one.<br>example:I got array[7,1,5,3,6,4];The correct output should be 5;</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><pre><code class="js">const maxProfit = function(prices)&#123;     //maxProfit在这里起到了比较下面profit大小的作用    if(prices === null || price.lenght === 0)&#123;return 0;&#125;    var min = Number.MAX_VALUE;    var profit = 0;    var i;    for(i=0;i&lt;prices.length;i++)&#123;        min = prices[i]&lt;min?:prices[i]:min; //7 1 1 1 1 1        profit = (prices[i] - min)&gt;profit?price[i]-min:profit;  //0 0 5-1  3-1  6-1 4-1    &#125;    return profit;&#125;</code></pre><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>[7,1,5,3,6,4]</p><pre><code class="js">const maxProfit = function (prices) &#123;    var profit = 0, diff;    var i;    for (i = 0; i &lt; prices.length - 1; i++) &#123;        diff = prices[i+1] - prices[i]; //1-7 5-1 3-5 6-3  4-6        if (diff &gt; 0) &#123; profit += diff; &#125; //4 3    &#125;    return profit; //4&#125;// 这里我想maxProfit是已经封装了max()函数，因为const不定义maxProfit老是报错</code></pre><p>一起回顾下max()方法</p><pre><code class="js">var max = Math.max(3,54,32,16);alert(max); //54</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Taste-Algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多对一数据绑定[template的妙用]</title>
    <link href="undefined2018/05/13/%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%5Btemplate%E7%9A%84%E5%A6%99%E7%94%A8%5D/"/>
    <url>2018/05/13/%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%5Btemplate%E7%9A%84%E5%A6%99%E7%94%A8%5D/</url>
    
    <content type="html"><![CDATA[<p>（新闻详情页面：Detail、新闻首页：Index、模拟本地数据：posts-data,js）<br><img src="https://images2018.cnblogs.com/blog/968267/201805/968267-20180513091744966-1885664133.gif"></p><h1 id="部分源码"><a href="#部分源码" class="headerlink" title="部分源码"></a>部分源码</h1><p><strong>Detail.wxml</strong></p><pre><code class="html">&lt;image class=&quot;head-image&quot; src=&quot;&#123;&#123;detail.headImgSrc&#125;&#125;&quot;&gt;&lt;/image&gt;&lt;view class=&quot;author-date&quot;&gt;  &lt;image class=&quot;avatar&quot; src=&quot;&#123;&#123;detail.avatar&#125;&#125;&quot;&gt;&lt;/image&gt;  &lt;text class=&quot;author&quot;&gt;&#123;&#123;detail.author&#125;&#125;&lt;/text&gt;  &lt;text class=&quot;const-text&quot;&gt;发表于&lt;/text&gt;  &lt;text class=&quot;date&quot;&gt;&#123;&#123;detail.dateTime&#125;&#125;&lt;/text&gt;&lt;/view&gt;&lt;view class=&quot;title&quot;&gt;&#123;&#123;detail.title&#125;&#125;&lt;/view&gt;&lt;text class=&quot;detail&quot;&gt;  &#123;&#123;detail.detail&#125;&#125;&lt;/text&gt;</code></pre><p><strong>Detail.JS</strong></p><pre><code class="js">var postsData = require(&#39;../../../data/posts-data.js&#39;)//这个新闻内容文件Page(&#123;    data: &#123;    &#125;,    onLoad: function (option) &#123;        var postId = option.id;        var postData = postsData.postList[postId];//这个方法是用来定义每个新闻列表对应的顺序是哪个新闻内容        //不管是不是在onLoad里面直接使用this.setData反正不会有错。        this.setData(&#123;            detail: postData //渲染到对应data中就是postData        &#125;);&#125;)</code></pre><p><strong>Index.wxml</strong></p><pre><code class="pre">&lt;import src=&quot;post-item/index-template.wxml&quot; /&gt;&lt;block wx:for=&quot;&#123;&#123;posts_key&#125;&#125;&quot; wx:for-item=&quot;item&quot; wx:for-index=&quot;idx&quot;&gt;&lt;!--把wx:for=&quot;&#123;&#123;posts_key&#125;&#125;&quot;，用数组的形式来绑定多个新闻块的内容，利用for循环来反复调用后台数据，如果没用用posts_key了，那么对应的item_这种命名就是不可以的--&gt;    &lt;!--item代表一个子元素，用item.xxx的方法来进行一个单一元素绑定--&gt;    &lt;!--//template--&gt;    &lt;view catchtap=&quot;onPostTap&quot; data-postId=&quot;&#123;&#123;item.postId&#125;&#125;&quot;&gt;&lt;!--postId方法用来确认点击的是哪一则新闻、data-postId自定义数据--&gt;      &lt;!--catch绑定事件就不会出发冒泡事件--&gt;      &lt;template is=&quot;postItem&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot; /&gt;&lt;!--使用...item就可以让template里面的变量前面不用加上item.了，否则都应该是item.变量名的写法--&gt;    &lt;/view&gt;  &lt;/block&gt;</code></pre><h1 id="template的使用"><a href="#template的使用" class="headerlink" title="template的使用"></a>template的使用</h1><p>index-template.wxml</p><pre><code class="html">&lt;template name=&quot;postItem&quot;&gt;  &lt;view class=&quot;post-container&quot;&gt;    &lt;view class=&quot;post-author-date&quot;&gt;      &lt;!--常见的一列四行布局--&gt;      &lt;image class=&quot;post-author&quot; src=&quot;&#123;&#123;avatar&#125;&#125;&quot;&gt;&lt;/image&gt;      &lt;text class=&quot;post-date&quot;&gt;&#123;&#123;date&#125;&#125;&lt;/text&gt;    &lt;/view&gt;    &lt;view&gt;      &lt;text class=&quot;post-title&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/text&gt;      &lt;image class=&quot;post-image&quot; src=&quot;&#123;&#123;imgSrc&#125;&#125;&quot;&gt;&lt;/image&gt;      &lt;text class=&quot;post-content&quot;&gt;&#123;&#123;content&#125;&#125;&lt;/text&gt;    &lt;/view&gt;    &lt;view class=&quot;post-like&quot;&gt;      &lt;image class=&quot;post-like-image&quot; src=&quot;../../images/icon/star.png&quot;&gt;&lt;/image&gt;      &lt;text class=&quot;post-like-font&quot;&gt;&#123;&#123;collection&#125;&#125;&lt;/text&gt;      &lt;image class=&quot;post-like-image&quot; src=&quot;../../images/icon/view.png&quot;&gt;&lt;/image&gt;      &lt;text class=&quot;post-like-font&quot;&gt;&#123;&#123;reading&#125;&#125;&lt;/text&gt;    &lt;/view&gt;  &lt;/view&gt;&lt;/template&gt;</code></pre><p><strong>Index.js</strong></p><pre><code class="js">var postsData = require(&quot;../../data/posts-data.js&quot;);Page(&#123;  data: &#123;&#125;,  /** 生命周期函数--监听页面加载*/  onLoad: function(options) &#123;    //页面初始化options为页面跳转所带来的参数    //把wxml中改成wx:for=&quot;&#123;&#123;posts_key&#125;&#125;&quot;，用数组的形式来绑定多个新闻块的内容，利用for循环来反复调用后台数据    this.setData(&#123;      posts_key: postsData.postList //渲染到对应data中就是posts_key:[]    &#125;);  &#125;,  onPostTap: function(event) &#123;    //用JS来捕获postId从而让事件知道我们点击的是哪条新闻，event是框架所给的默认事件对象。    var postId = event.currentTarget.dataset.postid; // currentTarget当前鼠标点击的一个事件对应wxml所绑定事件处的view，dataset所有的自定义数据的一个集合，wxml对应的就是data-postId。data自定义的字符只有连字符的第一个字母能大写，如果不是连字符的第一个字母，它默认会被转化为小写。所有我们在wxml定义一个data - postId后，在js中应用时就写成event.currentTarget.dateset.postid;    wx.navigateTo(&#123;      url: &quot;post-detail/detail?id=&quot; + postId //？id=&quot; + postId ? id+路径后面是接参数id 将postId传递到post-detail中从而让detail页面知道对应点击post里面哪篇文章跳转到哪篇页面    &#125;);  &#125;&#125;);</code></pre><h2 id="模拟本地数据库"><a href="#模拟本地数据库" class="headerlink" title="模拟本地数据库"></a>模拟本地数据库</h2><p><strong>Posts-data,js</strong></p><p>&#96;&#96;&#96;&#96;js<br>var local_database &#x3D; [<br>    {<br>        avatar: “&#x2F;images&#x2F;Catoon5.jpg”,<br>        date: “May 8 2018”,<br>        imgSrc: “&#x2F;images&#x2F;Catoon50.jpeg”,<br>        title: “以色列总理用“鞋”招待安倍，日外交官：这是冒犯，不知道我们进门都要脱鞋？”,<br>        content: ““日本首相觉得内塔尼亚胡家中鞋子上的甜点冒犯了他…。”,<br>        collection: “192”,<br>        reading: “9668”,<br>        &#x2F;&#x2F;下面的内容是post-detail里面的数据<br>        headImgSrc: “&#x2F;images&#x2F;Catoon50.jpeg”,<br>        author: “郭鹏飞”,<br>        dateTime: “三天前”,<br>        detail: “【环球网报道 记者 郭鹏飞】日本首相安倍晋三上周访问以色列，…”,<br>        postId: 0<br>    },<br>    {<br>        avatar: “&#x2F;images&#x2F;Catoon1.jpg”,<br>        date: “May 8 2018”,<br>        imgSrc: “&#x2F;images&#x2F;Catoon10.jpeg”,<br>        title: “欧文惨遭伤病”,<br>        content: “欧文已经因为膝盖酸痛问题休战了…”,<br>        collection: “92”,<br>        reading: “189”,<br>　　　　　&#x2F;&#x2F;下面内容是post-detail里面的数据　<br>        headImgSrc: “&#x2F;images&#x2F;Catoon10.jpeg”,<br>        author: “乔-瓦尔登”,<br>        dateTime: “三天前”,<br>        detail: “今天NBA主要发生了以下几件事情…”,<br>        postId: 1,<br>    },<br>]<br>module.exports &#x3D; {<br>    postList: local_database<br>}<br>&#96;&#96;&#96;</p>]]></content>
    
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一对一、模拟本地的数据库动态绑定数据</title>
    <link href="undefined2018/05/13/%E4%B8%80%E5%AF%B9%E4%B8%80%E3%80%81%E6%A8%A1%E6%8B%9F%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE/"/>
    <url>2018/05/13/%E4%B8%80%E5%AF%B9%E4%B8%80%E3%80%81%E6%A8%A1%E6%8B%9F%E6%9C%AC%E5%9C%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>核心：使用wx:for&#x3D;”“，用数组的形式来绑定多个的内容，利用for循环来反复调用后台数据，如果没用用posts_key了，那么对应的item_这种命名就是不可以的！<br><img src="https://images2018.cnblogs.com/blog/968267/201805/968267-20180513084046266-1777965348.png"><br><strong>Wxml</strong></p><pre><code class="html"> &lt;block wx:for=&quot;&#123;&#123;posts_key&#125;&#125;&quot; wx:for-item=&quot;item&quot; wx:for-index=&quot;idx&quot; wx:key=&quot;idx&quot;&gt;    &lt;view catchtap=&quot;onPostTap&quot; data-postId=&quot;&#123;&#123;item.postId&#125;&#125;&quot;&gt;      &lt;image src=&quot;&#123;&#123;item.images&#125;&#125;&quot;&gt;&lt;/image&gt;      &lt;text&gt;&#123;&#123;item.content&#125;&#125;&lt;/text&gt;    &lt;/view&gt;  &lt;/block&gt; </code></pre><p><strong>JS</strong></p><pre><code class="js">var postsData = require(&#39;../../data/skip-data.js&#39;)const app = getApp()Page(&#123;  data: &#123;  &#125;,  onLoad:function(options)&#123;    this.setData(&#123;      posts_key:postsData.postList    &#125;);  &#125;,&#125;)</code></pre><p>Skip-data.js(这个脚本用来模拟本地数据库)</p><pre><code class="json">var local_database = [  &#123;    content: &quot;VIPKID 纯北美外教 代言人刘涛&quot;,    images: &quot;/images/dian1@2x.png&quot;,    postId: 0,  &#125;,  &#123;    content: &quot;哒哒英语 专属外教 代言人孙俪&quot;,    images: &quot;/images/dian1@2x.png&quot;,    postId: 1,  &#125;,  &#123;    content: &quot;51Talk 高校教材 代言人贾乃亮&quot;,    images: &quot;/images/dian1@2x.png&quot;,    postId: 2,  &#125;,  &#123;    content: &quot;VipJr 量身定制课 代言人姚明&quot;,    images: &quot;/images/dian1@2x.png&quot;,    postId: 3,  &#125;,  &#123;    content: &quot;以上都想试听&quot;,    images: &quot;/images/dian1@2x.png&quot;,    postId: 4,  &#125;,]module.exports = &#123;  postList: local_database&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序点击切换图片、收藏功能的实现！</title>
    <link href="undefined2018/05/12/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%82%B9%E5%87%BB%E5%88%87%E6%8D%A2%E5%9B%BE%E7%89%87%E3%80%81%E6%94%B6%E8%97%8F%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%81/"/>
    <url>2018/05/12/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%82%B9%E5%87%BB%E5%88%87%E6%8D%A2%E5%9B%BE%E7%89%87%E3%80%81%E6%94%B6%E8%97%8F%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p><strong>大四写的小程序记录的笔记，刚从博客园迁移过来，写的很粗糙，后续再整理！</strong></p><p>微信小程序图片点击切换和收藏功能是非常常用的！有更好写法的请留言，喜欢小程序和 web 前端开发的请加我微信 Angelo_Sifan<br>效果图如下<br><img src="https://images2018.cnblogs.com/blog/968267/201805/968267-20180512090857705-567175825.gif"><br>首先对 Image 绑定相应变量，选用 catchxxx 而不选用 bindxxx 进行绑定是因为，catch 不会出发冒泡事件就不会向父节点传递，写的过程中一定要用 wx:if 和 wx:else 来进行判断。然后我们还需要在 JS 中对 onCollectionTap 变量进行定义，最后当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。</p><pre><code class="js">Page(&#123;    data: &#123;&#125;,    onLoad: function (option) &#123;    var postId = option.id;//要先在对应的数据文本中对每个栏目定义postId、比如postId: 0 postId:1    this.data.currentPostId = postId; //借助顶部data作为中转，拿到上面这行postid后，将它放到下面var postCollected = postsCollected[]中        //将这个postId从onLoad中传递到下面的onCollectionTap中        var postData = postsData.postList[postId];//定义每个新闻列表对应顺序是哪个新闻内容//用户收藏功能    var postsCollected = wx.getStorageSync(&#39;posts_collected&#39;) //从缓存中读取所有的缓存状态        if (postsCollected) &#123;   //postsCollected为真的情况，在缓存中存在            var postCollected = postsCollected[postId]//读取其中一个缓存状态            this.setData(&#123;                collected: postCollected //将是否被收藏的状态上绑定到collected这个变量上            &#125;)        &#125;        else &#123;       //为假的情况，缓存中为空的情况            var postsCollected = &#123; &#125;; //对postsCollected进行一个赋值操作，从而防止为空，从而省掉后面对它是否为空进行测试的步骤            postsCollected[postId] = false; // 让当前的这篇文章状态为false，从而收藏星星不点亮            wx.setStorageSync(&#39;posts_collected&#39;, postsCollected);//将postsCollected对象放到缓存中        &#125;    &#125;,    onCollectionTap: function (event) &#123;　　　　// 定义onCollectionTap事件用来确定文章是否收藏，如果没收藏就能点亮星星进行收藏        var postsCollected = wx.getStorageSync(&#39;posts_collected&#39;);   //获取缓存的方法        var postCollected = postsCollected[this.data.currentPostId];   //确定当前文章是否有缓存的状态，传递参数方法、借助其他参数来传递变量，如上的data        postCollected = !postCollected;// 取反操作，收藏变成未收藏、未收藏变为收藏        postsCollected[this.data.currentPostId] = postCollected;//整体缓存的某一篇文章的缓存值等于postCollected从而更新一个变量        wx.setStorageSync(&#39;posts_collected&#39;, postsCollected);//更新文章是否收藏的缓存值,相当于在数据库中做了一次更新。        //更新Data的数据绑定变量,从而实现图片切换        this.setData(&#123;            collected: postCollected //当前的collected为postCollected        &#125;)    &#125;)&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微信小程序之数据绑定的妙用！</title>
    <link href="undefined2018/05/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%A6%99%E7%94%A8%EF%BC%81/"/>
    <url>2018/05/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%A6%99%E7%94%A8%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<p><strong>大四写的小程序记录的笔记，刚从博客园迁移过来，写的很粗糙，后续再整理！</strong></p><!--post.wxml文件--><pre><code class="html">&lt;view&gt;  &lt;swiper indicator-dots=&quot;true&quot; autoplay=&quot;ture&quot; interval=&quot;5000&quot;&gt;    &lt;swiper-item&gt;      &lt;image src=&quot;/images/swiper3.jpeg&quot;&gt; &lt;/image&gt;    &lt;/swiper-item&gt;    &lt;swiper-item&gt;      &lt;image src=&quot;/images/swiper2.jpeg&quot;&gt;&lt;/image&gt;    &lt;/swiper-item&gt;    &lt;swiper-item&gt;      &lt;image src=&quot;/images/swiper1.jpeg&quot;&gt;&lt;/image&gt;    &lt;/swiper-item&gt;  &lt;/swiper&gt;  &lt;block wx:for=&quot;&#123;&#123;posts_key&#125;&#125;&quot; wx:for-item=&quot;item&quot;&gt;    &lt;!--block用来将包裹的代码变成一个整理,item代表一个子元素，用item.xxx的方法来进行一个单一元素绑定--&gt;    &lt;view class=&quot;post-container&quot;&gt;      &lt;view class=&quot;post-author-date&quot;&gt;        &lt;!-常见的一列四行布局--&gt;        &lt;image class=&quot;post-author&quot; src=&quot;&#123;&#123;item.author_img&#125;&#125;&quot;&gt;&lt;/image&gt;        &lt;text class=&quot;post-date&quot;&gt;&#123;&#123;item.date&#125;&#125;&lt;/text&gt;      &lt;/view&gt;      &lt;view&gt;        &lt;text class=&quot;post-title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/text&gt;        &lt;image class=&quot;post-image&quot; src=&quot;&#123;&#123;item.post_img&#125;&#125;&quot;&gt;&lt;/image&gt;        &lt;text class=&quot;post-content&quot;&gt;&#123;&#123;item.content&#125;&#125;&lt;/text&gt;      &lt;/view&gt;      &lt;view class=&quot;post-like&quot;&gt;        &lt;image class=&quot;post-like-image&quot; src=&quot;../../images/icon/star.png&quot;&gt;&lt;/image&gt;        &lt;text class=&quot;post-like-font&quot;&gt;&#123;&#123;item.view_num&#125;&#125;&lt;/text&gt;        &lt;image class=&quot;post-like-image&quot; src=&quot;../../images/icon/view.png&quot;&gt;&lt;/image&gt;        &lt;text class=&quot;post-like-font&quot;&gt;&#123;&#123;item.collect_num&#125;&#125;&lt;/text&gt;      &lt;/view&gt;    &lt;/view&gt;  &lt;/block&gt;&lt;/view&gt;</code></pre><pre><code class="js">var postsData = require(&#39;../../data/posts-data.js&#39;)Page(&#123;data: &#123;//小程序总是会读取 data 对象下面来做数据绑定，这个动作我们称为动作 A//而 A 的执行，是在 onLoad 事件执行之后发生的&#125;,/\*_ 生命周期函数--监听页面加载_/onLoad: function (options) &#123;//页面初始化 options 为页面跳转所带来的参数    //要把前面绑定的wxml中wx:for=&quot;&#123;&#123;posts_key&#125;&#125;&quot;再改成postList    //下面这种方法要把wxml中改成wx:for=&quot;&#123;&#123;posts_key&#125;&#125;&quot;    //用数组的形式来绑定多个新闻块的内容，利用for循环来反复调用后台数据    this.setData(&#123;       posts_key:postsData.postList //渲染到对应data中就是posts_key:[]       &#125;);&#125;&#125;)</code></pre><pre><code class="js">var local_database = [  &#123;    author_img: &quot;/images/Catoon5.jpg&quot;,    date: &quot;May 8 2018&quot;,    post_img: &quot;/images/Catoon50.jpeg&quot;,    title:      &quot;以色列总理用“鞋”招待安倍，日外交官：这是冒犯，不知道我们进门都要脱鞋？&quot;,    content:      &quot;“日本首相觉得内塔尼亚胡家中鞋子上的甜点冒犯了他，”《以色列时报》7 日报道称，日本首相安倍晋三上周对以色列进行正式访问，以色列总理内塔尼亚胡在官邸设宴招待来访的安倍夫妇时，官邸厨子却用鞋形餐具盛放甜点，这被视为“外交失礼”，对安倍的怠慢与侮辱。该报称，按照日本家庭文化，鞋子不仅远离桌子，而且还得脱了置于门外。&quot;,    view_num: &quot;192&quot;,    collect_num: &quot;9668&quot;  &#125;,  &#123;    author_img: &quot;/images/Catoon1.jpg&quot;,    date: &quot;May 8 2018&quot;,    post_img: &quot;/images/Catoon10.jpeg&quot;,    title: &quot;欧文惨遭伤病&quot;,    content:      &quot;欧文已经因为膝盖酸痛问题休战了十几天，这个伤对他来说其实是老问题了。在绿军公布决定之后，骑士随队记者乔-瓦尔登也在专栏中讨论了欧文膝伤的来龙去脉。&quot;,    view_num: &quot;92&quot;,    collect_num: &quot;189&quot;  &#125;,  &#123;    author_img: &quot;/images/Catoon2.jpg&quot;,    date: &quot;May 8 2018&quot;,    post_img: &quot;/images/Catoon20.jpeg&quot;,    title: &quot;骑士胜券在握詹姆斯打懵猛龙，骑士球迷却倒戈支持起了猛龙&quot;,    content:      &quot;要说联盟中哪支球队最命苦，那猛龙绝对当仁不让，要数哪个球员最心酸，那德罗赞绝对让人心疼。猛龙被骑士打的毫无还手之力，上赛季半决赛被骑士 4-0 横扫后，这赛季历史又惊人的相似，猛龙在半决赛中又被打的惨不忍睹。如果上赛季东部第三的猛龙被当时还拥有欧文的东部第二骑士打败还情有可原；那这赛季卷土重来，以东部榜首的姿态杀入季后赛的猛龙面对整个赛季都在动荡中挣扎的骑士又被打成这样，确实是让人感到有些扼腕。&quot;,    view_num: &quot;192&quot;,    collect_num: &quot;9668&quot;  &#125;,  &#123;    author_img: &quot;/images/Catoon3.jpg&quot;,    date: &quot;May 8 2018&quot;,    post_img: &quot;/images/Catoon30.jpeg&quot;,    title: &quot;陈冠希首谈意外怀孕产下的女儿,陈冠希首谈意外怀孕产下的女儿&quot;,    content:      &quot;近日，陈冠希在个人社交网站上发了一张女儿在沙滩上玩的照片，照片中 alaia 带着帽子，穿着吊带露肩装真是太可爱太萌了！老爸陈冠希还附言：priceless！知道什么意思吗？这是在说女儿是他的无价之宝！网友听了纷纷夸赞，都哑口无言了！&quot;,    view_num: &quot;232&quot;,    collect_num: &quot;7668&quot;  &#125;,  &#123;    author_img: &quot;/images/Catoon4.jpg&quot;,    date: &quot;May 8 2018&quot;,    post_img: &quot;/images/Catoon40.jpg&quot;,    title: &quot;贸易战博弈里中兴的曙光&quot;,    content:      &quot;与往常不同的是，这次会谈后双方都极为低调，各自披露的信息非常有限，更多的是语焉不详的框架性描述。从中文媒体的内容来看，基本上是新华社通稿和围绕通稿简短内容的延展性解读，信息量并不大。如果我们阅读外媒的相关报道，能够看到不少有价值的细节信息&quot;,    view_num: &quot;232&quot;,    collect_num: &quot;15468&quot;  &#125;,  &#123;    author_img: &quot;/images/Catoon6.jpeg&quot;,    date: &quot;May 8 2018&quot;,    post_img: &quot;/images/Catoon60.jpeg&quot;,    title: &quot;日媒：印度等国欲就美国钢铝进口限制向 WTO 起诉&quot;,    content:      &quot;海外网 5 月 8 日电 特朗普于 3 月 8 日表示，美国将对进口钢铁产品征收 25%关税、对进口铝产品征收 10%关税。日媒表示，如今，各国对特朗普政府 3 月启动的钢铝进口限制的反对仍未停息。对美钢铁出口额排名第十的印度显示出不排除向世界贸易组织（WTO）起诉的姿态；泰国在与美国的双边磋商中要求给予豁免；俄罗斯已在探讨反制措施。其背景之一是对部分国家很早就得到豁免的不满。&quot;,    view_num: &quot;192&quot;,    collect_num: &quot;9668&quot;  &#125;];module.exports = &#123;  postList: local_database //渲染到对应 data 中就是 posts_key:[]&#125;;</code></pre><p>本篇博客尚未写完，会在后期进行完善。</p>]]></content>
    
    
    
    <tags>
      
      <tag>微信小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>